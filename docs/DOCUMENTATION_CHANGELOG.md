# Documentation Changelog

This changelog tracks corrections and updates to the Oproto.FluentDynamoDb documentation.

## Purpose

This file is maintained **separately from the repository `CHANGELOG.md`** to facilitate synchronization with derived documentation maintained by other teams (e.g., website documentation at [fluentdynamodb.dev](https://fluentdynamodb.dev)).

The repository `CHANGELOG.md` tracks code changes, new features, and bug fixes. This file specifically tracks:
- Documentation corrections (fixing incorrect API references, outdated patterns)
- Documentation improvements (clarifications, additional examples)
- Documentation restructuring (file moves, reorganization)

## How to Use This Changelog

### For Documentation Maintainers

When syncing derived documentation:
1. Note the date of your last sync
2. Review all entries since that date
3. Apply the same corrections to your derived documentation
4. Update your sync date

### Entry Format

Each entry follows this structure:

```markdown
## [YYYY-MM-DD]

### File: path/to/file.md

**Before:**
```csharp
// incorrect code example
```

**After:**
```csharp
// corrected code example
```

**Reason:** Brief explanation of why this change was made.
```

### Categories

Entries may be categorized as:
- **API Correction**: Fixing incorrect method names or signatures
- **Pattern Update**: Updating code patterns to match current best practices
- **Clarification**: Adding notes or explanations for clarity
- **Example Fix**: Correcting code examples that wouldn't compile or work correctly

---

## Changelog Entries

<!-- Add new entries below this line, with most recent at the top -->

## [2025-12-04]

### File: Multiple documentation files - Put().ExecuteAsync() → PutAsync() corrections

**Category:** API Correction

**Summary:** Corrected remaining `Put().ExecuteAsync()` patterns to use the correct `PutAsync()` method across documentation and source files.

**Files corrected:**
- `docs/advanced-topics/AdvancedTypes.md` (2 occurrences)
- `docs/advanced-topics/TableGenerationCustomization.md` (10 occurrences)
- `docs/reference/AttributeReference.md` (1 occurrence)
- `docs/DOCUMENTATION_CHANGELOG.md` (1 occurrence - example code)
- `Oproto.FluentDynamoDb.SystemTextJson/README.md` (1 occurrence)
- `Oproto.FluentDynamoDb.NewtonsoftJson/README.md` (1 occurrence)
- `Oproto.FluentDynamoDb/Attributes/GenerateAccessorsAttribute.cs` (1 occurrence - XML documentation)
- `.kiro/specs/integration-test-build-fixes/design.md` (1 occurrence)

---

**Before:**
```csharp
await table.Documents.Put(document).ExecuteAsync();
await table.Orders.Put(order).ExecuteAsync();
await OrderLines.Put(line).ExecuteAsync();
```

**After:**
```csharp
await table.Documents.Put(document).PutAsync();
await table.Orders.Put(order).PutAsync();
await OrderLines.Put(line).PutAsync();
```

**Reason:** `ExecuteAsync()` does not exist on `PutItemRequestBuilder`. The correct method is `PutAsync()`. This is consistent with other request builders: `GetItemAsync()`, `UpdateAsync()`, `DeleteAsync()`.

---

## [2025-12-04]

### File: docs/DOCUMENTATION_CHANGELOG.md, docs/examples/ProjectionModelsExamples.md, docs/core-features/ProjectionModels.md, docs/advanced-topics/FieldLevelSecurity.md

**Category:** Pattern Update - Example Entity Cleanup

**Summary:** Cleaned up entity definitions in documentation to follow correct attribute patterns. Removed incorrect `[DynamoDbEntity]` attribute from table entities, removed manual `: IDynamoDbEntity` interface implementations, and removed redundant `CreatePk()`/`CreateSk()` methods.

---

**Before (Incorrect - combining attributes):**
```csharp
[DynamoDbEntity]  // ❌ Not needed for table entities
[DynamoDbTable("Orders")]
public partial class Order : IDynamoDbEntity  // ❌ Auto-generated by source generator
{
    [PartitionKey]
    [DynamoDbAttribute("pk")]
    public string Pk { get; set; } = string.Empty;

    [SortKey]
    [DynamoDbAttribute("sk")]
    public string Sk { get; set; } = string.Empty;
    
    // ❌ Duplicates source-generated key methods
    public static string CreatePk(string orderId) => $"ORDER#{orderId}";
    public static string CreateSk() => MetaSk;
}
```

**After (Correct - clean entity definition):**
```csharp
[DynamoDbTable("Orders")]
public partial class Order
{
    [PartitionKey(Prefix = "ORDER")]  // ✅ Configure prefix for generated Keys.Pk() method
    [DynamoDbAttribute("pk")]
    public string Pk { get; set; } = string.Empty;

    [SortKey]
    [DynamoDbAttribute("sk")]
    public string Sk { get; set; } = string.Empty;
    
    // ✅ Use source-generated Order.Keys.Pk(orderId) instead
}
```

**Reason:** 
- `[DynamoDbEntity]` is only for nested map types requiring hydration, not for top-level table entities
- `: IDynamoDbEntity` is automatically added by the source generator's partial class implementation
- Manual `CreatePk()`/`CreateSk()` methods duplicate the source-generated `Keys` class functionality
- Use `[PartitionKey(Prefix = "ORDER")]` to configure key formatting, then use `Order.Keys.Pk(orderId)` which returns `"ORDER#" + orderId`

---

**Before (Using manual key methods):**
```csharp
// Manual key construction
var pk = $"ORDER#{orderId}";
var sk = $"LINE#{lineId}";

// Or using manual CreatePk/CreateSk methods
var pk = Order.CreatePk(orderId);
var sk = OrderLine.CreateSk(lineId);
```

**After (Using source-generated Keys class):**
```csharp
// Use source-generated Keys class methods
var pk = Order.Keys.Pk(orderId);      // Returns "ORDER#" + orderId
var sk = OrderLine.Keys.Sk(lineId);   // Returns "LINE#" + lineId

// Or get both keys at once
var (pk, sk) = Order.Keys.Key(orderId, sortKeyValue);
```

**Reason:** The source generator creates a `Keys` nested class with `Pk()`, `Sk()`, and `Key()` methods that use the configured `Prefix` and `Separator` values from the key attributes. This eliminates manual key construction and ensures consistency.

---

## [2025-12-01]

### File: docs/core-features/QueryingData.md, docs/getting-started/SingleEntityTables.md

**Category:** Pattern Update - Scan Opt-In Pattern

**Before:**
```csharp
// Scan was available on all tables via base class
var allOrders = await table.Scan<Order>().ToListAsync();
```

**After:**
```csharp
// Scan now requires [Scannable] attribute on the entity
[DynamoDbTable("Orders")]
[Scannable]  // Required for Scan operations
public partial class Order { ... }

// Then use entity accessor or table method (if default entity)
var allOrders = await table.Orders.Scan().ToListAsync();
// Or for default entity:
var allOrders = await table.Scan().ToListAsync();
// Generic method still works when entity has [Scannable]:
var allOrders = await table.Scan<Order>().ToListAsync();
```

**Reason:** Scan operations are expensive and not a recommended DynamoDB access pattern. The `table.Scan<TEntity>()` method has been removed from `DynamoDbTableBase` to enforce an opt-in pattern. Developers must now explicitly add the `[Scannable]` attribute to entities that need Scan support. This prevents accidental table scans and encourages proper access pattern design.

**Migration Steps:**
1. Add `[Scannable]` attribute to entities that require Scan operations
2. Update code from `table.Scan<TEntity>()` to use entity accessor `table.Entitys.Scan()` or `table.Scan()` for default entity
3. The generic `table.Scan<TEntity>()` method is still available when the entity has `[Scannable]` attribute

---

## [2025-12-01]

### File: docs/core-features/BasicOperations.md

**Category:** API Correction

**Before:**
```csharp
var orderLines = await table.OrderLines.Query()
    .Where(x => x.OrderId == "order123")
    .ExecuteAsync();
```

**After:**
```csharp
var orderLines = await table.OrderLines.Query()
    .Where(x => x.OrderId == "order123")
    .ToListAsync();
```

**Reason:** `ExecuteAsync()` does not exist on QueryRequestBuilder. The correct method is `ToListAsync()` for returning a list of entities.

---

**Before:**
```csharp
await table.Put<User>().WithItem(user).ExecuteAsync();
```

**After:**
```csharp
await table.Put<User>().WithItem(user).PutAsync();
```

**Reason:** `ExecuteAsync()` does not exist on PutItemRequestBuilder. The correct method is `PutAsync()`.

---

**Before:**
```csharp
var response = await table.Get<User>()
    .WithKey(User.Fields.UserId, User.Keys.Pk("user123"))
    .WithKey(User.Fields.ProfileType, User.Keys.Sk("MAIN"))
    .ExecuteAsync();
```

**After:**
```csharp
var response = await table.Get<User>()
    .WithKey(User.Fields.UserId, User.Keys.Pk("user123"))
    .WithKey(User.Fields.ProfileType, User.Keys.Sk("MAIN"))
    .GetItemAsync();
```

**Reason:** `ExecuteAsync()` does not exist on GetItemRequestBuilder. The correct method is `GetItemAsync()`.

---

**Before:**
```csharp
var users = await table.Query<User>()
    .Where($"{User.Fields.UserId} = {{0}}", User.Keys.Pk("user123"))
    .ExecuteAsync();
```

**After:**
```csharp
var users = await table.Query<User>()
    .Where($"{User.Fields.UserId} = {{0}}", User.Keys.Pk("user123"))
    .ToListAsync();
```

**Reason:** `ExecuteAsync()` does not exist on QueryRequestBuilder. The correct method is `ToListAsync()`.

---

**Before:**
```csharp
await table.Delete<User>()
    .WithKey(User.Fields.UserId, User.Keys.Pk("user123"))
    .WithKey(User.Fields.ProfileType, User.Keys.Sk("MAIN"))
    .ExecuteAsync();
```

**After:**
```csharp
await table.Delete<User>()
    .WithKey(User.Fields.UserId, User.Keys.Pk("user123"))
    .WithKey(User.Fields.ProfileType, User.Keys.Sk("MAIN"))
    .DeleteAsync();
```

**Reason:** `ExecuteAsync()` does not exist on DeleteItemRequestBuilder. The correct method is `DeleteAsync()`.

---

**Before:**
```csharp
await table.Get<User>()
    .WithKey(User.Fields.UserId, pk)
    .WithKey(User.Fields.ProfileType, sk)
    .ExecuteAsync();
```

**After:**
```csharp
await table.Get<User>()
    .WithKey(User.Fields.UserId, pk)
    .WithKey(User.Fields.ProfileType, sk)
    .GetItemAsync();
```

**Reason:** `ExecuteAsync()` does not exist on GetItemRequestBuilder. The correct method is `GetItemAsync()`.

---

**Before:**
```csharp
var orders = await table.Query<Order>()
    .UsingIndex(Order.Indexes.StatusIndex)
    .Where($"{Order.Fields.Status} = {{0}}", Order.Keys.StatusIndex.Pk("pending"))
    .ExecuteAsync();
```

**After:**
```csharp
var orders = await table.Query<Order>()
    .UsingIndex(Order.Indexes.StatusIndex)
    .Where($"{Order.Fields.Status} = {{0}}", Order.Keys.StatusIndex.Pk("pending"))
    .ToListAsync();
```

**Reason:** `ExecuteAsync()` does not exist on QueryRequestBuilder. The correct method is `ToListAsync()`.

---

**Before:**
```csharp
await table.Update
    .WithKey(UserFields.UserId, UserKeys.Pk("user123"))
    .Set($"SET {UserFields.Name} = if_not_exists({UserFields.Name}, {{0}})", "Default Name")
    .ExecuteAsync();
```

**After:**
```csharp
await table.Update
    .WithKey(UserFields.UserId, UserKeys.Pk("user123"))
    .Set($"SET {UserFields.Name} = if_not_exists({UserFields.Name}, {{0}})", "Default Name")
    .UpdateAsync();
```

**Reason:** `ExecuteAsync()` does not exist on UpdateItemRequestBuilder. The correct method is `UpdateAsync()`.

---

**Before (Performance Considerations section):**
```csharp
.ExecuteAsync<User>()
// and
.UsingConsistentRead().ExecuteAsync<User>()
// and
await table.Get.WithKey(...).ExecuteAsync();
// and
await table.Put.WithItem(user).ExecuteAsync();
```

**After:**
```csharp
.GetItemAsync()
// and
.UsingConsistentRead().GetItemAsync()
// and
await table.Get.WithKey(...).GetItemAsync();
// and
await table.Put.WithItem(user).PutAsync();
```

**Reason:** Updated generic examples in Performance Considerations and Error Handling sections to use correct method names (`GetItemAsync()`, `PutAsync()`) instead of non-existent `ExecuteAsync()`.

---

### File: docs/core-features/QueryingData.md

**Category:** API Correction

**Before:**
```csharp
await table.Query
    .Where<User>(x => x.UserId == userId && x.SortKey.StartsWith("ORDER#"))
    .WithFilter<User>(x => x.Status == "ACTIVE" && x.Age >= 18)
    .ExecuteAsync();
```

**After:**
```csharp
await table.Query
    .Where<User>(x => x.UserId == userId && x.SortKey.StartsWith("ORDER#"))
    .WithFilter<User>(x => x.Status == "ACTIVE" && x.Age >= 18)
    .ToListAsync();
```

**Reason:** `ExecuteAsync()` does not exist on QueryRequestBuilder. The correct method is `ToListAsync()` for returning a list of entities.

---

**Before:**
```csharp
var response = await scannableTable.Scan
    .ExecuteAsync();
```

**After:**
```csharp
var response = await scannableTable.Scan
    .ToListAsync();
```

**Reason:** `ExecuteAsync()` does not exist on ScanRequestBuilder. The correct method is `ToListAsync()`.

---

**Summary of QueryingData.md corrections:**
- Replaced all `ExecuteAsync()` calls on Query builders with `ToListAsync()`
- Replaced all `ExecuteAsync()` calls on Scan builders with `ToListAsync()`
- Updated pagination examples to use `ToListAsync()`
- Updated GSI query examples to use `ToListAsync()`
- Updated performance optimization examples to use `ToListAsync()`
- Total of 35+ ExecuteAsync references corrected

---

## [2025-12-01]

### File: docs/core-features/BasicOperations.md

**Category:** Pattern Update

**Before (Put with Return Values):**
```csharp
// Builder API required for return values
var response = await table.Users.Put(user)
    .ReturnAllOldValues()
    .PutAsync();

// Check if an item was replaced
if (response.Attributes != null && response.Attributes.Count > 0)
{
    var oldUser = UserMapper.FromAttributeMap(response.Attributes);
    Console.WriteLine($"Replaced user: {oldUser.Name}");
}
```

**After:**
```csharp
// Option 1: Use ToDynamoDbResponseAsync to get the raw AWS SDK response
var response = await table.Users.Put(user)
    .ReturnAllOldValues()
    .ToDynamoDbResponseAsync();

if (response.Attributes != null && response.Attributes.Count > 0)
{
    var oldUser = UserMapper.FromAttributeMap(response.Attributes);
    Console.WriteLine($"Replaced user: {oldUser.Name}");
}

// Option 2: Primary API populates DynamoDbOperationContext automatically
await table.Users.Put(user)
    .ReturnAllOldValues()
    .PutAsync();

var context = DynamoDbOperationContext.Current;
if (context?.PreOperationValues != null && context.PreOperationValues.Count > 0)
{
    var oldUser = context.DeserializePreOperationValue<User>();
    // ...
}
```

**Reason:** `PutAsync()` returns `Task` (void), not a response object. To access `response.Attributes`, use `ToDynamoDbResponseAsync()` which returns the raw AWS SDK response. Alternatively, use `DynamoDbOperationContext.Current.PreOperationValues` for context-based access. Added warning about AsyncLocal not being suitable for unit testing.

---

**Before (Update with Return Values):**
```csharp
var response = await table.Users.Update("user123")
    .Set(x => new UserUpdateModel { Name = "Jane Doe" })
    .ReturnAllNewValues()
    .UpdateAsync();

var updatedUser = UserMapper.FromAttributeMap(response.Attributes);
```

**After:**
```csharp
// Option 1: Use ToDynamoDbResponseAsync
var response = await table.Users.Update("user123")
    .Set(x => new UserUpdateModel { Name = "Jane Doe" })
    .ReturnAllNewValues()
    .ToDynamoDbResponseAsync();

var updatedUser = UserMapper.FromAttributeMap(response.Attributes);

// Option 2: Use context-based access
await table.Users.Update("user123")
    .Set(x => new UserUpdateModel { Name = "Jane Doe" })
    .ReturnAllNewValues()
    .UpdateAsync();

var context = DynamoDbOperationContext.Current;
var updatedUser = context?.DeserializePostOperationValue<User>();
```

**Reason:** `UpdateAsync()` returns `Task` (void), not a response object. To access `response.Attributes`, use `ToDynamoDbResponseAsync()`. Added alternative using `DynamoDbOperationContext.Current.PostOperationValues` and warning about AsyncLocal.

---

**Before (Delete with Return Values):**
```csharp
var response = await table.Users.Delete("user123")
    .ReturnAllOldValues()
    .DeleteAsync();

if (response.Attributes != null && response.Attributes.Count > 0)
{
    var deletedUser = UserMapper.FromAttributeMap(response.Attributes);
    // ...
}
```

**After:**
```csharp
// Option 1: Use ToDynamoDbResponseAsync
var response = await table.Users.Delete("user123")
    .ReturnAllOldValues()
    .ToDynamoDbResponseAsync();

if (response.Attributes != null && response.Attributes.Count > 0)
{
    var deletedUser = UserMapper.FromAttributeMap(response.Attributes);
    // ...
}

// Option 2: Use context-based access
await table.Users.Delete("user123")
    .ReturnAllOldValues()
    .DeleteAsync();

var context = DynamoDbOperationContext.Current;
var deletedUser = context?.DeserializePreOperationValue<User>();
```

**Reason:** `DeleteAsync()` returns `Task` (void), not a response object. To access `response.Attributes`, use `ToDynamoDbResponseAsync()`. Added alternative using `DynamoDbOperationContext.Current.PreOperationValues` and warning about AsyncLocal.

---

**Before (Mixing Patterns - CreateUserAsync):**
```csharp
public async Task<User?> CreateUserAsync(User user)
{
    var response = await _table.Users.Put(user)
        .Where("attribute_not_exists({0})", User.Fields.UserId)
        .ReturnAllOldValues()
        .PutAsync();
    
    return response.Attributes != null 
        ? UserMapper.FromAttributeMap(response.Attributes) 
        : null;
}
```

**After:**
```csharp
public async Task<User?> CreateUserAsync(User user)
{
    var response = await _table.Users.Put(user)
        .Where("attribute_not_exists({0})", User.Fields.UserId)
        .ReturnAllOldValues()
        .ToDynamoDbResponseAsync();
    
    return response.Attributes != null 
        ? UserMapper.FromAttributeMap(response.Attributes) 
        : null;
}
```

**Reason:** Changed `PutAsync()` to `ToDynamoDbResponseAsync()` since the code needs to access `response.Attributes` directly.


---

## [2025-12-01]

### File: Oproto.FluentDynamoDb/Requests/DeleteItemRequestBuilder.cs

**Category:** API Correction (XML Documentation)

**Before:**
```csharp
/// // Simple delete by primary key
/// await table.Delete<Transaction>()
///     .WithKey("id", "user123")
///     .ExecuteAsync();
/// 
/// // Conditional delete with return values
/// var response = await table.Delete<Transaction>()
///     .WithKey("pk", "USER", "sk", "user123")
///     .Where("attribute_exists(#status)")
///     .WithAttribute("#status", "status")
///     .ReturnAllOldValues()
///     .ExecuteAsync();
```

**After:**
```csharp
/// // Simple delete by primary key
/// await table.Delete<Transaction>()
///     .WithKey("id", "user123")
///     .DeleteAsync();
/// 
/// // Conditional delete with return values (use ToDynamoDbResponseAsync to access response.Attributes)
/// var response = await table.Delete<Transaction>()
///     .WithKey("pk", "USER", "sk", "user123")
///     .Where("attribute_exists(#status)")
///     .WithAttribute("#status", "status")
///     .ReturnAllOldValues()
///     .ToDynamoDbResponseAsync();
```

**Reason:** `ExecuteAsync()` does not exist on DeleteItemRequestBuilder. The correct methods are `DeleteAsync()` for void operations and `ToDynamoDbResponseAsync()` when accessing response attributes.

---

### File: Oproto.FluentDynamoDb/Requests/UpdateItemRequestBuilder.cs

**Category:** API Correction (XML Documentation)

**Before:**
```csharp
/// // Update specific attributes
/// var response = await table.Update<Transaction>()
///     .WithKey("id", "123")
///     .Set("SET #name = :name, #status = :status")
///     ...
///     .ExecuteAsync();
/// 
/// // Conditional update
/// var response = await table.Update<Transaction>()
///     .WithKey("id", "123")
///     .Set("SET #count = #count + :inc")
///     .Where("attribute_exists(id)")
///     ...
///     .ExecuteAsync();
```

**After:**
```csharp
/// // Update specific attributes
/// await table.Update<Transaction>()
///     .WithKey("id", "123")
///     .Set("SET #name = :name, #status = :status")
///     ...
///     .UpdateAsync();
/// 
/// // Conditional update with return values (use ToDynamoDbResponseAsync to access response.Attributes)
/// var response = await table.Update<Transaction>()
///     .WithKey("id", "123")
///     .Set("SET #count = #count + :inc")
///     .Where("attribute_exists(id)")
///     ...
///     .ReturnAllNewValues()
///     .ToDynamoDbResponseAsync();
```

**Reason:** `ExecuteAsync()` does not exist on UpdateItemRequestBuilder. The correct methods are `UpdateAsync()` for void operations and `ToDynamoDbResponseAsync()` when accessing response attributes.

---

### File: Oproto.FluentDynamoDb/Requests/PutItemRequestBuilder.cs

**Category:** API Correction (XML Documentation)

**Before:**
```csharp
/// // Put an entity
/// var response = await table.Put<MyEntity>()
///     .WithItem(myEntity)
///     .ExecuteAsync();
/// 
/// // Put with raw attributes
/// var response = await table.Put<MyEntity>()
///     .WithItem(new Dictionary<string, AttributeValue> { ... })
///     .ExecuteAsync();
/// 
/// // Conditional put (only if item doesn't exist)
/// var response = await table.Put<MyEntity>()
///     .WithItem(myEntity)
///     .Where("attribute_not_exists(id)")
///     .ExecuteAsync();
```

**After:**
```csharp
/// // Put an entity
/// await table.Put<MyEntity>()
///     .WithItem(myEntity)
///     .PutAsync();
/// 
/// // Put with raw attributes
/// await table.Put<MyEntity>()
///     .WithItem(new Dictionary<string, AttributeValue> { ... })
///     .PutAsync();
/// 
/// // Conditional put with return values (use ToDynamoDbResponseAsync to access response.Attributes)
/// var response = await table.Put<MyEntity>()
///     .WithItem(myEntity)
///     .Where("attribute_not_exists(id)")
///     .ReturnAllOldValues()
///     .ToDynamoDbResponseAsync();
```

**Reason:** `ExecuteAsync()` does not exist on PutItemRequestBuilder. The correct methods are `PutAsync()` for void operations and `ToDynamoDbResponseAsync()` when accessing response attributes. Also corrected the `WithItem<T>` method example.


## [2025-12-01]

### File: docs/advanced-topics/CompositeEntities.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`
- Replaced `ExecuteAsync()` on Query builders with `ToListAsync()`
- Replaced `ExecuteAsync<T>()` on Query builders with `Query<T>().ToListAsync()`
- Replaced `ExecuteAsync<T>()` on Get builders with `Get<T>().GetItemAsync()`
- Replaced `ExecuteAsync()` on TransactWrite builders with `CommitAsync()`

**Reason:** `ExecuteAsync()` does not exist on these request builders. The correct methods are `PutAsync()`, `ToListAsync()`, `GetItemAsync()`, and `CommitAsync()` respectively.

---

### File: docs/advanced-topics/STSIntegration.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync<User>()` on Get builders with `Get<User>().GetItemAsync()`
- Replaced `ExecuteAsync<User>()` on Query builders with `Query<User>().ToListAsync()`
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`
- Replaced `ExecuteAsync()` on Update builders with `UpdateAsync()`
- Replaced `ExecuteAsync()` on Delete builders with `DeleteAsync()`
- Replaced `ExecuteAsync()` on TransactWrite builders with `CommitAsync()`

**Reason:** `ExecuteAsync()` does not exist on these request builders. The correct methods are `GetItemAsync()`, `ToListAsync()`, `PutAsync()`, `UpdateAsync()`, `DeleteAsync()`, and `CommitAsync()` respectively.

---

### File: docs/advanced-topics/MultiEntityTables.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`
- Replaced `ExecuteAsync()` on Query builders with `ToListAsync()`
- Replaced `ExecuteAsync()` on Get builders with `GetItemAsync()`
- Replaced `ExecuteAsync()` on TransactWrite builders with `CommitAsync()`
- Replaced `ExecuteAsync()` on Scan builders with `ToListAsync()`

**Reason:** `ExecuteAsync()` does not exist on these request builders. The correct methods are `PutAsync()`, `ToListAsync()`, `GetItemAsync()`, `CommitAsync()` respectively.

---

### File: docs/advanced-topics/Discriminators.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync<User>()` on Query builders with `Query<User>().ToListAsync()`
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`

**Reason:** `ExecuteAsync()` does not exist on these request builders. The correct methods are `ToListAsync()` and `PutAsync()` respectively.

---

### File: docs/advanced-topics/PerformanceOptimization.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync<T>()` on Get builders with `Get<T>().GetItemAsync()`
- Replaced `ExecuteAsync<T>()` on Query builders with `Query<T>().ToListAsync()`
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`
- Replaced `ExecuteAsync()` on Scan builders with `ToListAsync()`
- Replaced `ExecuteAsync()` on Query builders with `ToListAsync()`

**Reason:** `ExecuteAsync()` does not exist on these request builders. The correct methods are `GetItemAsync()`, `ToListAsync()`, and `PutAsync()` respectively. Note: `ExecuteAsync()` is correct for BatchGetItemRequestBuilder and BatchWriteItemRequestBuilder.



---

### File: docs/examples/AdvancedTypesExamples.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`
- Replaced `ExecuteAsync()` on Update builders with `UpdateAsync()`
- Replaced `ExecuteAsync<T>()` on Get builders with `Get<T>().GetItemAsync()`
- Replaced `ExecuteAsync<T>()` on Query builders with `Query<T>().ToListAsync()`

**Reason:** `ExecuteAsync()` does not exist on these request builders. The correct methods are `PutAsync()`, `UpdateAsync()`, `GetItemAsync()`, and `ToListAsync()` respectively.

---

### File: docs/examples/ProjectionModelsExamples.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Query builders with `ToListAsync()`

**Reason:** `ExecuteAsync()` does not exist on QueryRequestBuilder. The correct method is `ToListAsync()`.

---

### File: docs/examples/EntitySpecificBuildersExamples.md

**Category:** Pattern Update

**Summary of corrections:**
- Changed `UpdateAsync()` to `ToDynamoDbResponseAsync()` when accessing `response.Attributes`

**Reason:** `UpdateAsync()` returns `Task` (void), not a response object. To access `response.Attributes`, use `ToDynamoDbResponseAsync()` which returns the raw AWS SDK response.



---

### File: docs/getting-started/Installation.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`

**Reason:** `ExecuteAsync()` does not exist on PutItemRequestBuilder. The correct method is `PutAsync()`.

---

### File: docs/getting-started/QuickStart.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Get builders with `GetItemAsync()`
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`
- Replaced `ExecuteAsync()` on Update builders with `UpdateAsync()`
- Replaced `ExecuteAsync()` on Delete builders with `DeleteAsync()`
- Replaced `ExecuteAsync()` on Query builders with `ToListAsync()`

**Reason:** `ExecuteAsync()` does not exist on these request builders. The correct methods are `GetItemAsync()`, `PutAsync()`, `UpdateAsync()`, `DeleteAsync()`, and `ToListAsync()` respectively.

---

### File: docs/getting-started/FirstEntity.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Get builders with `GetItemAsync()`
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`
- Replaced `ExecuteAsync()` on Update builders with `UpdateAsync()`
- Replaced `ExecuteAsync()` on Query builders with `ToListAsync()`

**Reason:** `ExecuteAsync()` does not exist on these request builders. The correct methods are `GetItemAsync()`, `PutAsync()`, `UpdateAsync()`, and `ToListAsync()` respectively.

---

### File: docs/getting-started/SingleEntityTables.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Get builders with `GetItemAsync()`
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`
- Replaced `ExecuteAsync()` on Update builders with `UpdateAsync()`
- Replaced `ExecuteAsync()` on Delete builders with `DeleteAsync()`
- Replaced `ExecuteAsync()` on Query builders with `ToListAsync()`
- Replaced `ExecuteAsync()` on Scan builders with `ToListAsync()`
- Replaced `ExecuteAsync()` on DynamoDbTransactions.Write with `CommitAsync()`

**Reason:** `ExecuteAsync()` does not exist on these request builders. The correct methods are `GetItemAsync()`, `PutAsync()`, `UpdateAsync()`, `DeleteAsync()`, `ToListAsync()`, and `CommitAsync()` respectively. Note: `ExecuteAsync()` is correct for DynamoDbBatch.Write and DynamoDbBatch.Get.



---

### File: docs/reference/LoggingTroubleshooting.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Query builders with `ToListAsync()`

**Reason:** `ExecuteAsync()` does not exist on QueryRequestBuilder. The correct method is `ToListAsync()`. Note: `ExecuteAsync()` is correct for BatchGet operations.

---

### File: docs/reference/FormatSpecifiers.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Query builders with `ToListAsync()`

**Reason:** `ExecuteAsync()` does not exist on QueryRequestBuilder. The correct method is `ToListAsync()`. Note: Many ExecuteAsync references remain in this file for Update and Delete operations that need further review.

---

### File: docs/reference/ApiImprovementsMigration.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`

**Reason:** `ExecuteAsync()` does not exist on PutItemRequestBuilder. The correct method is `PutAsync()`. Note: Many ExecuteAsync references remain in this file for Query operations that need further review.

---

### File: docs/reference/AdoptionGuide.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`

**Reason:** `ExecuteAsync()` does not exist on PutItemRequestBuilder. The correct method is `PutAsync()`.

---

### File: docs/reference/AdvancedTypesQuickReference.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Update builders with `UpdateAsync()`
- Replaced `ExecuteAsync()` on Query builders with `ToListAsync()`

**Reason:** `ExecuteAsync()` does not exist on these request builders. The correct methods are `UpdateAsync()` and `ToListAsync()` respectively.

---

### File: docs/reference/ErrorHandling.md

**Category:** API Correction

**Summary of corrections:**
- Replaced `ExecuteAsync()` on Put builders with `PutAsync()`
- Replaced `ExecuteAsync()` on Update builders with `UpdateAsync()`
- Replaced `ExecuteAsync()` on Delete builders with `DeleteAsync()`

**Reason:** `ExecuteAsync()` does not exist on these request builders. The correct methods are `PutAsync()`, `UpdateAsync()`, and `DeleteAsync()` respectively.

---

### File: docs/SourceGeneratorGuide.md

**Category:** API Correction

**Before:**
```csharp
// Introduction text
The Oproto.FluentDynamoDb source generator automatically creates entity mapping code, field constants, key builders, and enhanced ExecuteAsync methods...

// Put operation
await transactionsTable.Put(transaction)
    .ExecuteAsync();

// Get operation
var response = await transactionsTable.Get()
    .WithKey(TransactionFields.TenantId, TransactionKeys.Pk("tenant123"))
    .WithKey(TransactionFields.TransactionId, TransactionKeys.Sk("txn456"))
    .ExecuteAsync();

// Multi-entity Put operations
await ecommerceTable.Orders.Put(order)
    .ExecuteAsync();
await ecommerceTable.OrderLines.Put(orderLine)
    .ExecuteAsync();

// Query operations
var orders = await ecommerceTable.Orders.Query()
    .Where($"{OrderFields.CustomerId} = {{0}}", OrderKeys.Pk("customer123"))
    .ExecuteAsync();

// Manual pattern Get
var response = await table.Get()
    .WithKey(...)
    .ExecuteAsync<Transaction>();

// Query with strongly-typed results
var queryResponse = await table.Query()
    .Where($"{TransactionFields.TenantId} = :pk", new { pk = TransactionKeys.Pk("tenant123") })
    .ExecuteAsync<Transaction>();

// GSI Query
var statusResponse = await table.Query<Transaction>()
    .UsingIndex("StatusIndex")
    .Where($"{Transaction.Fields.Status} = {{0}}", "pending")
    .ExecuteAsync<Transaction>();

// Multi-item entity query
var response = await table.Query()
    .Where(...)
    .ExecuteAsync<TransactionWithEntries>();

// STS scoped client
var response = await _table.Get()
    .WithClient(scopedClient)
    .WithKey(...)
    .ExecuteAsync<Transaction>();

// FluentResults integration
var result = await table.Get()
    .WithKey(...)
    .ExecuteAsync<Transaction>();

// Migration guide
3. Replace manual mapping code with generated `ExecuteAsync<T>()` calls
```

**After:**
```csharp
// Introduction text
The Oproto.FluentDynamoDb source generator automatically creates entity mapping code, field constants, key builders, and type-safe async methods...

// Put operation
await transactionsTable.Put(transaction)
    .PutAsync();

// Get operation
var transaction = await transactionsTable.Get()
    .WithKey(TransactionFields.TenantId, TransactionKeys.Pk("tenant123"))
    .WithKey(TransactionFields.TransactionId, TransactionKeys.Sk("txn456"))
    .GetItemAsync();

// Multi-entity Put operations
await ecommerceTable.Orders.Put(order)
    .PutAsync();
await ecommerceTable.OrderLines.Put(orderLine)
    .PutAsync();

// Query operations
var orders = await ecommerceTable.Orders.Query()
    .Where($"{OrderFields.CustomerId} = {{0}}", OrderKeys.Pk("customer123"))
    .ToListAsync();

// Manual pattern Get
var response = await table.Get<Transaction>()
    .WithKey(...)
    .GetItemAsync();

// Query with strongly-typed results
var transactions = await table.Query<Transaction>()
    .Where($"{TransactionFields.TenantId} = :pk", new { pk = TransactionKeys.Pk("tenant123") })
    .ToListAsync();

// GSI Query
var pendingTransactions = await table.Query<Transaction>()
    .UsingIndex("StatusIndex")
    .Where($"{Transaction.Fields.Status} = {{0}}", "pending")
    .ToListAsync();

// Multi-item entity query
var transactionsWithEntries = await table.Query<TransactionWithEntries>()
    .Where(...)
    .ToListAsync();

// STS scoped client
var transaction = await _table.Get<Transaction>()
    .WithClient(scopedClient)
    .WithKey(...)
    .GetItemAsync();

// FluentResults integration
var result = await table.Get<Transaction>()
    .WithKey(...)
    .GetItemAsync();

// Migration guide
3. Replace manual mapping code with generated type-safe async methods (`GetItemAsync()`, `PutAsync()`, `ToListAsync()`, etc.)
```

**Reason:** `ExecuteAsync()` does not exist on these request builders. The correct methods are:
- `PutAsync()` for PutItemRequestBuilder
- `GetItemAsync()` for GetItemRequestBuilder
- `ToListAsync()` for QueryRequestBuilder and ScanRequestBuilder
- Updated introduction text to reflect accurate terminology
- Updated migration guide to reference correct method names



---

## [2025-12-04]

### File: Oproto.FluentDynamoDb.SystemTextJson/README.md

**Category:** Pattern Update - JSON Serializer Refactor

**Summary:** Complete rewrite of the SystemTextJson package README to document the new runtime configuration pattern via `FluentDynamoDbOptions` instead of the removed compile-time assembly attribute approach.

---

**Before (Old assembly attribute pattern):**
```csharp
// Assembly-level configuration (compile-time)
[assembly: DynamoDbJsonSerializer(JsonSerializerType.SystemTextJson)]

// Entity with JsonBlob
[DynamoDbTable("documents")]
public partial class Document
{
    [JsonBlob]
    [DynamoDbAttribute("content")]
    public DocumentContent Content { get; set; }
}

// Usage - no way to customize serializer options
var table = new DocumentTable(client, "documents");
```

**After (New runtime configuration pattern):**
```csharp
using Oproto.FluentDynamoDb;
using Oproto.FluentDynamoDb.SystemTextJson;

// Entity with JsonBlob (no assembly attribute needed)
[DynamoDbTable("documents")]
public partial class Document
{
    [JsonBlob]
    [DynamoDbAttribute("content")]
    public DocumentContent Content { get; set; }
}

// Configure at runtime with options
var options = new FluentDynamoDbOptions()
    .WithSystemTextJson();  // Default options

// Or with custom JsonSerializerOptions
var options = new FluentDynamoDbOptions()
    .WithSystemTextJson(new JsonSerializerOptions 
    { 
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase 
    });

// Or for AOT with JsonSerializerContext
var options = new FluentDynamoDbOptions()
    .WithSystemTextJson(MyJsonContext.Default);

var table = new DocumentTable(client, "documents", options);
```

**Reason:** The JSON serialization system was refactored from compile-time assembly attributes to runtime configuration via `FluentDynamoDbOptions`. This enables users to customize serializer options (camelCase, null handling, etc.) and provides full AOT compatibility with `JsonSerializerContext`.

---

### File: Oproto.FluentDynamoDb.NewtonsoftJson/README.md

**Category:** Pattern Update - JSON Serializer Refactor

**Summary:** Complete rewrite of the NewtonsoftJson package README to document the new runtime configuration pattern via `FluentDynamoDbOptions` instead of the removed compile-time assembly attribute approach.

---

**Before (Old assembly attribute pattern):**
```csharp
// Assembly-level configuration (compile-time)
[assembly: DynamoDbJsonSerializer(JsonSerializerType.NewtonsoftJson)]

// Entity with JsonBlob
[DynamoDbTable("documents")]
public partial class Document
{
    [JsonBlob]
    [DynamoDbAttribute("content")]
    public DocumentContent Content { get; set; }
}

// Usage - no way to customize serializer settings
var table = new DocumentTable(client, "documents");
```

**After (New runtime configuration pattern):**
```csharp
using Oproto.FluentDynamoDb;
using Oproto.FluentDynamoDb.NewtonsoftJson;

// Entity with JsonBlob (no assembly attribute needed)
[DynamoDbTable("documents")]
public partial class Document
{
    [JsonBlob]
    [DynamoDbAttribute("content")]
    public DocumentContent Content { get; set; }
}

// Configure at runtime with options
var options = new FluentDynamoDbOptions()
    .WithNewtonsoftJson();  // Default settings

// Or with custom JsonSerializerSettings
var options = new FluentDynamoDbOptions()
    .WithNewtonsoftJson(new JsonSerializerSettings 
    { 
        ContractResolver = new CamelCasePropertyNamesContractResolver() 
    });

var table = new DocumentTable(client, "documents", options);
```

**Reason:** The JSON serialization system was refactored from compile-time assembly attributes to runtime configuration via `FluentDynamoDbOptions`. This enables users to customize serializer settings and provides a consistent configuration pattern across all FluentDynamoDb options.

---

### File: docs/advanced-topics/AdvancedTypes.md

**Category:** Pattern Update - JSON Serializer Refactor

**Summary:** Updated the JSON Blob Serialization section to document the new runtime configuration pattern. Removed all references to the `[assembly: DynamoDbJsonSerializer]` attribute and replaced with `FluentDynamoDbOptions` configuration examples.

---

**Before (Old assembly attribute pattern):**
```csharp
// Assembly-level configuration
[assembly: DynamoDbJsonSerializer(JsonSerializerType.SystemTextJson)]

// Entity with JsonBlob
[DynamoDbTable("documents")]
public partial class Document
{
    [JsonBlob]
    [DynamoDbAttribute("content")]
    public DocumentContent Content { get; set; }
}
```

**After (New runtime configuration pattern):**
```csharp
using Oproto.FluentDynamoDb;
using Oproto.FluentDynamoDb.SystemTextJson;

// Entity with JsonBlob
[DynamoDbTable("documents")]
public partial class Document
{
    [JsonBlob]
    [DynamoDbAttribute("content")]
    public DocumentContent Content { get; set; }
}

// Configure FluentDynamoDbOptions with JSON serializer
var options = new FluentDynamoDbOptions()
    .WithSystemTextJson();

var table = new DocumentTable(dynamoDbClient, "documents", options);
```

**Reason:** JSON serialization is now configured at runtime via `FluentDynamoDbOptions` instead of compile-time assembly attributes. This provides flexibility to customize serializer options and supports AOT-compatible `JsonSerializerContext`.

---

**Before (Error handling section):**
```csharp
// DYNDB102: Missing JSON serializer package
[JsonBlob]
public ComplexObject Data { get; set; } // Warning: Add SystemTextJson or NewtonsoftJson package
```

**After (Error handling section):**
```csharp
// Compile-time: DYNDB102 warning when [JsonBlob] used without JSON package reference
// Runtime: InvalidOperationException when no JSON serializer configured

// This will throw InvalidOperationException at runtime:
var options = new FluentDynamoDbOptions(); // No JSON serializer configured!
var table = new DocumentTable(dynamoDbClient, "documents", options);

await table.Documents.Put(document).PutAsync();
// InvalidOperationException: Property 'Content' has [JsonBlob] attribute but no JSON serializer is configured. 
// Call .WithSystemTextJson() or .WithNewtonsoftJson() on FluentDynamoDbOptions.
```

**Reason:** Added documentation for the new runtime exception that occurs when `[JsonBlob]` properties are used without configuring a JSON serializer via `FluentDynamoDbOptions`.

---

### File: docs/reference/AttributeReference.md

**Category:** Pattern Update - JSON Serializer Refactor

**Summary:** Removed the `[DynamoDbJsonSerializer]` attribute section entirely as this attribute has been deleted. The JSON serialization is now configured via `FluentDynamoDbOptions` at runtime.

---

**Before:**
```markdown
## [DynamoDbJsonSerializer]

Assembly-level attribute to configure JSON serialization for `[JsonBlob]` properties.

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `serializerType` | `JsonSerializerType` | Yes | The JSON serializer to use |

### Example

```csharp
[assembly: DynamoDbJsonSerializer(JsonSerializerType.SystemTextJson)]
```
```

**After:**
Section removed entirely. JSON serialization is now documented in the `[JsonBlob]` attribute section with reference to `FluentDynamoDbOptions` configuration.

**Reason:** The `[assembly: DynamoDbJsonSerializer]` attribute and `JsonSerializerType` enum have been deleted as part of the JSON serializer refactor. JSON serialization is now configured at runtime via `FluentDynamoDbOptions.WithSystemTextJson()` or `FluentDynamoDbOptions.WithNewtonsoftJson()`.

---

### File: docs/reference/AdvancedTypesQuickReference.md

**Category:** Pattern Update - JSON Serializer Refactor

**Summary:** Updated the JSON Blobs section to show the new runtime configuration pattern via `FluentDynamoDbOptions`.

---

**Before:**
```csharp
// Assembly-level configuration
[assembly: DynamoDbJsonSerializer(JsonSerializerType.SystemTextJson)]

[DynamoDbAttribute("content")]
[JsonBlob]
public ComplexObject Content { get; set; }
```

**After:**
```csharp
// 1. Define entity with [JsonBlob] property
[DynamoDbTable("documents")]
public partial class Document
{
    [DynamoDbAttribute("content")]
    [JsonBlob]
    public ComplexObject Content { get; set; } = new();
}

// 2. Configure FluentDynamoDbOptions with JSON serializer
var options = new FluentDynamoDbOptions()
    .WithSystemTextJson();  // or .WithNewtonsoftJson()

// 3. Create table with options
var table = new DocumentTable(dynamoDbClient, "documents", options);
```

**Reason:** JSON serialization is now configured at runtime via `FluentDynamoDbOptions` instead of compile-time assembly attributes.

---

### File: docs/examples/AdvancedTypesExamples.md

**Category:** Pattern Update - JSON Serializer Refactor

**Summary:** Updated all JSON Blob examples to show the new runtime configuration pattern via `FluentDynamoDbOptions`.

---

**Before:**
```csharp
// Install: dotnet add package Oproto.FluentDynamoDb.SystemTextJson
// Add assembly attribute
[assembly: DynamoDbJsonSerializer(JsonSerializerType.SystemTextJson)]

[DynamoDbTable("orders")]
public partial class Order
{
    [DynamoDbAttribute("details")]
    [JsonBlob]
    public OrderDetails Details { get; set; }
}

// Usage
var order = new Order { ... };
await orderTable.Put.WithItem(order).PutAsync();
```

**After:**
```csharp
// Install: dotnet add package Oproto.FluentDynamoDb.SystemTextJson
using Oproto.FluentDynamoDb.SystemTextJson;

[DynamoDbTable("orders")]
public partial class Order
{
    [DynamoDbAttribute("details")]
    [JsonBlob]
    public OrderDetails Details { get; set; }
}

// Configure JSON serialization at runtime
var options = new FluentDynamoDbOptions()
    .WithSystemTextJson();  // Uses default options

// Or with custom options
var customOptions = new FluentDynamoDbOptions()
    .WithSystemTextJson(new JsonSerializerOptions
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        WriteIndented = false
    });

var orderTable = new OrderTable(dynamoDbClient, "orders", options);

// Usage
var order = new Order { ... };
await orderTable.Put.WithItem(order).PutAsync();
```

**Reason:** JSON serialization is now configured at runtime via `FluentDynamoDbOptions` instead of compile-time assembly attributes. This enables customization of serializer options.

---

### File: docs/QUICK_REFERENCE.md

**Category:** Pattern Update - JSON Serializer Refactor

**Summary:** Updated the JSON Blob section in the Advanced Types quick reference to show the new runtime configuration pattern.

---

**Before:**
```csharp
// Assembly-level configuration
[assembly: DynamoDbJsonSerializer(JsonSerializerType.SystemTextJson)]

[DynamoDbAttribute("content")]
[JsonBlob]
public ComplexObject Content { get; set; }
```

**After:**
```csharp
// 1. Define entity with [JsonBlob] property
[DynamoDbTable("documents")]
public partial class Document
{
    [DynamoDbAttribute("content")]
    [JsonBlob]
    public ComplexObject Content { get; set; } = new();
}

// 2. Configure FluentDynamoDbOptions with JSON serializer
var options = new FluentDynamoDbOptions()
    .WithSystemTextJson();  // or .WithNewtonsoftJson()

// Custom serializer options
var jsonOptions = new JsonSerializerOptions
{
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase
};
var options = new FluentDynamoDbOptions()
    .WithSystemTextJson(jsonOptions);

// AOT-compatible with JsonSerializerContext
var options = new FluentDynamoDbOptions()
    .WithSystemTextJson(MyJsonContext.Default);
```

**Reason:** JSON serialization is now configured at runtime via `FluentDynamoDbOptions` instead of compile-time assembly attributes.

---

### Summary of JSON Serializer Refactor Documentation Changes

**Breaking Changes Documented:**

1. **Removed `[assembly: DynamoDbJsonSerializer]` attribute** - No longer exists, replaced by runtime configuration
2. **Removed `JsonSerializerType` enum** - No longer needed
3. **Changed `IDynamoDbEntity` interface** - `ToDynamoDb`/`FromDynamoDb` methods now accept `FluentDynamoDbOptions?` instead of `IDynamoDbLogger?`

**New Features Documented:**

1. **`IJsonBlobSerializer` interface** - Core interface for JSON serialization
2. **`FluentDynamoDbOptions.WithJsonSerializer()`** - Builder method for configuring JSON serializer
3. **`WithSystemTextJson()` extension methods** - Configure System.Text.Json with default, custom, or AOT-compatible options
4. **`WithNewtonsoftJson()` extension methods** - Configure Newtonsoft.Json with default or custom settings
5. **Runtime exception** - Clear error message when `[JsonBlob]` used without configured serializer

**Files Updated:**
- `Oproto.FluentDynamoDb.SystemTextJson/README.md`
- `Oproto.FluentDynamoDb.NewtonsoftJson/README.md`
- `docs/advanced-topics/AdvancedTypes.md`
- `docs/reference/AttributeReference.md`
- `docs/reference/AdvancedTypesQuickReference.md`
- `docs/examples/AdvancedTypesExamples.md`
- `docs/QUICK_REFERENCE.md`
