using Oproto.FluentDynamoDb.SourceGenerator.Models;
using System.Text;

namespace Oproto.FluentDynamoDb.SourceGenerator.Generators;

/// <summary>
/// Generates entity mapping code for converting between C# objects and DynamoDB AttributeValue dictionaries.
/// </summary>
public static class MapperGenerator
{
    /// <summary>
    /// Generates the complete entity implementation with IDynamoDbEntity interface methods.
    /// </summary>
    /// <param name="entity">The entity model to generate mapping code for.</param>
    /// <returns>The generated C# source code.</returns>
    public static string GenerateEntityImplementation(EntityModel entity)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using Amazon.DynamoDBv2.Model;");
        sb.AppendLine("using Oproto.FluentDynamoDb.Storage;");
        sb.AppendLine("using Oproto.FluentDynamoDb.Attributes;");
        sb.AppendLine();
        sb.AppendLine($"namespace {entity.Namespace}");
        sb.AppendLine("{");
        sb.AppendLine($"    public partial class {entity.ClassName} : IDynamoDbEntity");
        sb.AppendLine("    {");
        
        GenerateToDynamoDbMethod(sb, entity);
        GenerateFromDynamoDbSingleMethod(sb, entity);
        GenerateFromDynamoDbMultiMethod(sb, entity);
        GenerateGetPartitionKeyMethod(sb, entity);
        GenerateMatchesEntityMethod(sb, entity);
        GenerateGetEntityMetadataMethod(sb, entity);
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }

    private static void GenerateToDynamoDbMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Converts an entity instance to a DynamoDB AttributeValue dictionary.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static Dictionary<string, AttributeValue> ToDynamoDb<TSelf>(TSelf entity) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (entity is not {entity.ClassName} typedEntity)");
        sb.AppendLine($"                throw new ArgumentException($\"Expected {entity.ClassName}, got {{entity.GetType().Name}}\", nameof(entity));");
        sb.AppendLine();
        sb.AppendLine("            var item = new Dictionary<string, AttributeValue>();");
        sb.AppendLine();

        // Generate property mappings
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyToAttributeValue(sb, property);
        }

        sb.AppendLine();
        sb.AppendLine("            return item;");
        sb.AppendLine("        }");
    }

    private static void GeneratePropertyToAttributeValue(StringBuilder sb, PropertyModel property)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        
        // Handle nullable properties
        if (property.IsNullable)
        {
            sb.AppendLine($"            if (typedEntity.{propertyName} != null)");
            sb.AppendLine("            {");
            sb.AppendLine($"                item[\"{attributeName}\"] = {GetToAttributeValueExpression(property, $"typedEntity.{propertyName}")};");
            sb.AppendLine("            }");
        }
        else
        {
            sb.AppendLine($"            item[\"{attributeName}\"] = {GetToAttributeValueExpression(property, $"typedEntity.{propertyName}")};");
        }
    }

    private static string GetToAttributeValueExpression(PropertyModel property, string valueExpression)
    {
        var baseType = GetBaseType(property.PropertyType);
        
        return baseType switch
        {
            "string" => $"new AttributeValue {{ S = {valueExpression} }}",
            "int" or "System.Int32" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "long" or "System.Int64" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "double" or "System.Double" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "float" or "System.Single" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "decimal" or "System.Decimal" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "bool" or "System.Boolean" => $"new AttributeValue {{ BOOL = {valueExpression} }}",
            "DateTime" or "System.DateTime" => $"new AttributeValue {{ S = {valueExpression}.ToString(\"O\") }}",
            "DateTimeOffset" or "System.DateTimeOffset" => $"new AttributeValue {{ S = {valueExpression}.ToString(\"O\") }}",
            "Guid" or "System.Guid" => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            "Ulid" => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            "byte[]" or "System.Byte[]" => $"new AttributeValue {{ B = new MemoryStream({valueExpression}) }}",
            _ when IsEnumType(property.PropertyType) => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            _ => $"new AttributeValue {{ S = {valueExpression}?.ToString() ?? \"\" }}"
        };
    }

    private static void GenerateFromDynamoDbSingleMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Creates an entity instance from a single DynamoDB item.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static TSelf FromDynamoDb<TSelf>(Dictionary<string, AttributeValue> item) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (typeof(TSelf) != typeof({entity.ClassName}))");
        sb.AppendLine($"                throw new ArgumentException($\"Expected {entity.ClassName}, got {{typeof(TSelf).Name}}\");");
        sb.AppendLine();
        sb.AppendLine($"            var entity = new {entity.ClassName}();");
        sb.AppendLine();

        // Generate property mappings from AttributeValue
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyFromAttributeValue(sb, property);
        }

        sb.AppendLine();
        sb.AppendLine("            return (TSelf)(object)entity;");
        sb.AppendLine("        }");
    }

    private static void GeneratePropertyFromAttributeValue(StringBuilder sb, PropertyModel property)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        
        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("            {");
        sb.AppendLine($"                entity.{propertyName} = {GetFromAttributeValueExpression(property, $"{propertyName.ToLowerInvariant()}Value")};");
        sb.AppendLine("            }");
    }

    private static string GetFromAttributeValueExpression(PropertyModel property, string valueExpression)
    {
        var baseType = GetBaseType(property.PropertyType);
        var isNullable = property.IsNullable;
        
        var conversion = baseType switch
        {
            "string" => $"{valueExpression}.S",
            "int" or "System.Int32" => $"int.Parse({valueExpression}.N)",
            "long" or "System.Int64" => $"long.Parse({valueExpression}.N)",
            "double" or "System.Double" => $"double.Parse({valueExpression}.N)",
            "float" or "System.Single" => $"float.Parse({valueExpression}.N)",
            "decimal" or "System.Decimal" => $"decimal.Parse({valueExpression}.N)",
            "bool" or "System.Boolean" => $"{valueExpression}.BOOL",
            "DateTime" or "System.DateTime" => $"DateTime.Parse({valueExpression}.S)",
            "DateTimeOffset" or "System.DateTimeOffset" => $"DateTimeOffset.Parse({valueExpression}.S)",
            "Guid" or "System.Guid" => $"Guid.Parse({valueExpression}.S)",
            "Ulid" => $"Ulid.Parse({valueExpression}.S)",
            "byte[]" or "System.Byte[]" => $"{valueExpression}.B.ToArray()",
            _ when IsEnumType(property.PropertyType) => $"Enum.Parse<{baseType}>({valueExpression}.S)",
            _ => $"{valueExpression}.S"
        };

        return conversion;
    }

    private static void GenerateFromDynamoDbMultiMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Creates an entity instance from multiple DynamoDB items.");
        sb.AppendLine("        /// For single-item entities, uses the first item. For multi-item entities, combines all items.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static TSelf FromDynamoDb<TSelf>(IList<Dictionary<string, AttributeValue>> items) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine("            if (items == null || items.Count == 0)");
        sb.AppendLine($"                throw new ArgumentException(\"Items collection cannot be null or empty\", nameof(items));");
        sb.AppendLine();
        
        if (entity.IsMultiItemEntity)
        {
            sb.AppendLine("            // Multi-item entity: combine all items into a single entity");
            sb.AppendLine("            // For now, use the first item as the base and handle collections in future tasks");
            sb.AppendLine("            return FromDynamoDb<TSelf>(items[0]);");
        }
        else
        {
            sb.AppendLine("            // Single-item entity: use the first item");
            sb.AppendLine("            return FromDynamoDb<TSelf>(items[0]);");
        }
        
        sb.AppendLine("        }");
    }

    private static void GenerateGetPartitionKeyMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Extracts the partition key value from a DynamoDB item.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static string GetPartitionKey(Dictionary<string, AttributeValue> item)");
        sb.AppendLine("        {");
        
        var partitionKeyProperty = entity.PartitionKeyProperty;
        if (partitionKeyProperty != null)
        {
            sb.AppendLine($"            if (item.TryGetValue(\"{partitionKeyProperty.AttributeName}\", out var pkValue))");
            sb.AppendLine("            {");
            sb.AppendLine("                return pkValue.S ?? string.Empty;");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            return string.Empty;");
        }
        else
        {
            sb.AppendLine("            // No partition key defined");
            sb.AppendLine("            return string.Empty;");
        }
        
        sb.AppendLine("        }");
    }

    private static void GenerateMatchesEntityMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Determines whether a DynamoDB item matches this entity type.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static bool MatchesEntity(Dictionary<string, AttributeValue> item)");
        sb.AppendLine("        {");
        
        // For basic implementation, check if required attributes exist
        var requiredAttributes = entity.Properties
            .Where(p => p.HasAttributeMapping && (p.IsPartitionKey || !p.IsNullable))
            .ToArray();
        
        if (requiredAttributes.Length > 0)
        {
            sb.AppendLine("            // Check if required attributes exist");
            foreach (var property in requiredAttributes)
            {
                sb.AppendLine($"            if (!item.ContainsKey(\"{property.AttributeName}\"))");
                sb.AppendLine("                return false;");
            }
            sb.AppendLine();
        }
        
        // Check entity discriminator if present
        if (!string.IsNullOrEmpty(entity.EntityDiscriminator))
        {
            sb.AppendLine($"            // Check entity discriminator");
            sb.AppendLine($"            if (item.TryGetValue(\"EntityType\", out var entityTypeValue))");
            sb.AppendLine("            {");
            sb.AppendLine($"                return entityTypeValue.S == \"{entity.EntityDiscriminator}\";");
            sb.AppendLine("            }");
            sb.AppendLine();
        }
        
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
    }

    private static void GenerateGetEntityMetadataMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Gets metadata about the entity structure for future LINQ support.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static EntityMetadata GetEntityMetadata()");
        sb.AppendLine("        {");
        sb.AppendLine("            return new EntityMetadata");
        sb.AppendLine("            {");
        sb.AppendLine($"                TableName = \"{entity.TableName}\",");
        
        if (!string.IsNullOrEmpty(entity.EntityDiscriminator))
        {
            sb.AppendLine($"                EntityDiscriminator = \"{entity.EntityDiscriminator}\",");
        }
        
        sb.AppendLine($"                IsMultiItemEntity = {entity.IsMultiItemEntity.ToString().ToLowerInvariant()},");
        sb.AppendLine("                Properties = new PropertyMetadata[]");
        sb.AppendLine("                {");
        
        // Generate property metadata
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyMetadata(sb, property);
        }
        
        sb.AppendLine("                },");
        sb.AppendLine("                Indexes = new IndexMetadata[]");
        sb.AppendLine("                {");
        
        // Generate index metadata
        foreach (var index in entity.Indexes)
        {
            GenerateIndexMetadata(sb, index);
        }
        
        sb.AppendLine("                },");
        sb.AppendLine("                Relationships = new RelationshipMetadata[]");
        sb.AppendLine("                {");
        
        // Generate relationship metadata
        foreach (var relationship in entity.Relationships)
        {
            GenerateRelationshipMetadata(sb, relationship);
        }
        
        sb.AppendLine("                }");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
    }

    private static void GeneratePropertyMetadata(StringBuilder sb, PropertyModel property)
    {
        sb.AppendLine("                    new PropertyMetadata");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        PropertyName = \"{property.PropertyName}\",");
        sb.AppendLine($"                        AttributeName = \"{property.AttributeName}\",");
        sb.AppendLine($"                        PropertyType = typeof({GetTypeForMetadata(property.PropertyType)}),");
        sb.AppendLine($"                        IsPartitionKey = {property.IsPartitionKey.ToString().ToLowerInvariant()},");
        sb.AppendLine($"                        IsSortKey = {property.IsSortKey.ToString().ToLowerInvariant()},");
        sb.AppendLine($"                        IsCollection = {property.IsCollection.ToString().ToLowerInvariant()},");
        sb.AppendLine($"                        IsNullable = {property.IsNullable.ToString().ToLowerInvariant()},");
        
        // Add supported operations if available
        if (property.Queryable?.HasSupportedOperations == true)
        {
            var operations = string.Join(", ", property.Queryable.SupportedOperations.Select(op => $"DynamoDbOperation.{op}"));
            sb.AppendLine($"                        SupportedOperations = new[] {{ {operations} }},");
        }
        else
        {
            sb.AppendLine("                        SupportedOperations = Array.Empty<DynamoDbOperation>(),");
        }
        
        // Add available indexes if specified
        if (property.Queryable?.HasIndexRestrictions == true)
        {
            var indexes = string.Join(", ", property.Queryable.AvailableInIndexes.Select(idx => $"\"{idx}\""));
            sb.AppendLine($"                        AvailableInIndexes = new[] {{ {indexes} }},");
        }
        
        // Add key format if available
        if (property.KeyFormat != null)
        {
            sb.AppendLine("                        KeyFormat = new KeyFormatMetadata");
            sb.AppendLine("                        {");
            if (!string.IsNullOrEmpty(property.KeyFormat.Prefix))
            {
                sb.AppendLine($"                            Prefix = \"{property.KeyFormat.Prefix}\",");
            }
            if (property.KeyFormat.Separator != "#")
            {
                sb.AppendLine($"                            Separator = \"{property.KeyFormat.Separator}\"");
            }
            sb.AppendLine("                        }");
        }
        
        sb.AppendLine("                    },");
    }

    private static void GenerateIndexMetadata(StringBuilder sb, IndexModel index)
    {
        sb.AppendLine("                    new IndexMetadata");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        IndexName = \"{index.IndexName}\",");
        sb.AppendLine($"                        PartitionKeyProperty = \"{index.PartitionKeyProperty}\",");
        
        if (!string.IsNullOrEmpty(index.SortKeyProperty))
        {
            sb.AppendLine($"                        SortKeyProperty = \"{index.SortKeyProperty}\",");
        }
        
        if (index.ProjectedProperties.Length > 0)
        {
            var projectedProps = string.Join(", ", index.ProjectedProperties.Select(p => $"\"{p}\""));
            sb.AppendLine($"                        ProjectedProperties = new[] {{ {projectedProps} }},");
        }
        else
        {
            sb.AppendLine("                        ProjectedProperties = Array.Empty<string>(),");
        }
        
        if (!string.IsNullOrEmpty(index.PartitionKeyFormat))
        {
            sb.AppendLine($"                        KeyFormat = \"{index.PartitionKeyFormat}\"");
        }
        
        sb.AppendLine("                    },");
    }

    private static void GenerateRelationshipMetadata(StringBuilder sb, RelationshipModel relationship)
    {
        sb.AppendLine("                    new RelationshipMetadata");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        PropertyName = \"{relationship.PropertyName}\",");
        sb.AppendLine($"                        SortKeyPattern = \"{relationship.SortKeyPattern}\",");
        
        if (!string.IsNullOrEmpty(relationship.EntityType))
        {
            sb.AppendLine($"                        EntityType = typeof({relationship.EntityType}),");
        }
        
        sb.AppendLine($"                        IsCollection = {relationship.IsCollection.ToString().ToLowerInvariant()}");
        sb.AppendLine("                    },");
    }

    private static string GetBaseType(string typeName)
    {
        // Remove nullable annotations and generic type parameters
        var baseType = typeName.TrimEnd('?');
        
        // Handle nullable value types like int?, bool?, etc.
        if (baseType.StartsWith("System.Nullable<") && baseType.EndsWith(">"))
        {
            var innerType = baseType.Substring(16, baseType.Length - 17); // Remove "System.Nullable<" and ">"
            return innerType;
        }
        
        return baseType;
    }

    private static string GetTypeForMetadata(string typeName)
    {
        // For metadata, we need the actual type without nullable annotations
        var baseType = GetBaseType(typeName);
        
        // Convert common type aliases to full type names for typeof()
        return baseType switch
        {
            "string" => "string",
            "int" => "int",
            "long" => "long", 
            "double" => "double",
            "float" => "float",
            "decimal" => "decimal",
            "bool" => "bool",
            "byte[]" => "byte[]",
            _ => baseType
        };
    }

    private static bool IsEnumType(string typeName)
    {
        // This is a simplified check - in a real implementation, we'd use semantic analysis
        // For now, assume any type not in our known primitives might be an enum
        var baseType = GetBaseType(typeName);
        var knownPrimitives = new[]
        {
            "string", "int", "long", "double", "float", "decimal", "bool", "DateTime", "DateTimeOffset",
            "Guid", "byte[]", "System.String", "System.Int32", "System.Int64", "System.Double", 
            "System.Single", "System.Decimal", "System.Boolean", "System.DateTime", "System.DateTimeOffset",
            "System.Guid", "System.Byte[]", "Ulid"
        };
        
        return !knownPrimitives.Contains(baseType) && 
               !baseType.StartsWith("System.Collections.Generic.") &&
               !baseType.StartsWith("List<") &&
               !baseType.StartsWith("IList<") &&
               !baseType.StartsWith("ICollection<") &&
               !baseType.StartsWith("IEnumerable<");
    }
}