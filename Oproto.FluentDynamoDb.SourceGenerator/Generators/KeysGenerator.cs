using Oproto.FluentDynamoDb.SourceGenerator.Models;
using System.Text;

namespace Oproto.FluentDynamoDb.SourceGenerator.Generators;

/// <summary>
/// Generates static key builder methods for DynamoDB entities.
/// </summary>
public static class KeysGenerator
{
    /// <summary>
    /// Generates a static Keys class containing key builder methods for the entity.
    /// </summary>
    /// <param name="entity">The entity model to generate key builders for.</param>
    /// <returns>The generated C# source code.</returns>
    public static string GenerateKeysClass(EntityModel entity)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {entity.Namespace}");
        sb.AppendLine("{");
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Key builder methods for {entity.ClassName} DynamoDB keys.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static partial class {entity.ClassName}Keys");
        sb.AppendLine("    {");
        
        // Generate main table key builders
        GenerateMainTableKeyBuilders(sb, entity);
        
        // Generate GSI key builder classes
        GenerateGsiKeyBuilderClasses(sb, entity);
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }
    
    /// <summary>
    /// Generates key builder methods for the main table partition and sort keys.
    /// </summary>
    private static void GenerateMainTableKeyBuilders(StringBuilder sb, EntityModel entity)
    {
        // Generate partition key builder
        if (entity.PartitionKeyProperty != null)
        {
            GeneratePartitionKeyBuilder(sb, entity.PartitionKeyProperty, "Pk", isMainTable: true);
        }
        
        // Generate sort key builder if exists
        if (entity.SortKeyProperty != null)
        {
            GenerateSortKeyBuilder(sb, entity.SortKeyProperty, "Sk", isMainTable: true);
        }
        
        // Generate composite key builder if both keys exist
        if (entity.PartitionKeyProperty != null && entity.SortKeyProperty != null)
        {
            GenerateCompositeKeyBuilder(sb, entity.PartitionKeyProperty, entity.SortKeyProperty, "Key", isMainTable: true);
        }
    }
    
    /// <summary>
    /// Generates nested key builder classes for Global Secondary Indexes.
    /// </summary>
    private static void GenerateGsiKeyBuilderClasses(StringBuilder sb, EntityModel entity)
    {
        if (entity.Indexes.Length == 0)
            return;
            
        foreach (var index in entity.Indexes.OrderBy(i => i.IndexName))
        {
            GenerateGsiKeyBuilderClass(sb, entity, index);
        }
    }
    
    /// <summary>
    /// Generates a nested key builder class for a specific GSI.
    /// </summary>
    private static void GenerateGsiKeyBuilderClass(StringBuilder sb, EntityModel entity, IndexModel index)
    {
        var className = GetSafeClassName($"{index.IndexName}Keys");
        
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>");
        sb.AppendLine($"        /// Key builder methods for {index.IndexName} Global Secondary Index.");
        sb.AppendLine($"        /// </summary>");
        sb.AppendLine($"        public static partial class {className}");
        sb.AppendLine("        {");
        
        // Get partition key property for this GSI
        var partitionKeyProperty = entity.Properties.FirstOrDefault(p => p.PropertyName == index.PartitionKeyProperty);
        if (partitionKeyProperty != null)
        {
            GeneratePartitionKeyBuilder(sb, partitionKeyProperty, "Pk", isMainTable: false, index);
        }
        
        // Get sort key property for this GSI if exists
        if (!string.IsNullOrEmpty(index.SortKeyProperty))
        {
            var sortKeyProperty = entity.Properties.FirstOrDefault(p => p.PropertyName == index.SortKeyProperty);
            if (sortKeyProperty != null)
            {
                GenerateSortKeyBuilder(sb, sortKeyProperty, "Sk", isMainTable: false, index);
            }
        }
        
        // Generate composite key builder if both keys exist
        if (partitionKeyProperty != null && !string.IsNullOrEmpty(index.SortKeyProperty))
        {
            var sortKeyProperty = entity.Properties.FirstOrDefault(p => p.PropertyName == index.SortKeyProperty);
            if (sortKeyProperty != null)
            {
                GenerateCompositeKeyBuilder(sb, partitionKeyProperty, sortKeyProperty, "Key", isMainTable: false, index);
            }
        }
        
        sb.AppendLine("        }");
    }
    
    /// <summary>
    /// Generates a partition key builder method.
    /// </summary>
    private static void GeneratePartitionKeyBuilder(StringBuilder sb, PropertyModel property, string methodName, bool isMainTable, IndexModel? index = null)
    {
        var keyFormat = GetKeyFormat(property, index, isPartitionKey: true);
        var parameterType = GetParameterType(property.PropertyType);
        var parameterName = GetParameterName(property.PropertyName);
        
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>");
        sb.AppendLine($"        /// Builds the partition key value for {property.PropertyName}.");
        if (!isMainTable && index != null)
        {
            sb.AppendLine($"        /// Used for {index.IndexName} Global Secondary Index.");
        }
        sb.AppendLine($"        /// </summary>");
        sb.AppendLine($"        /// <param name=\"{parameterName}\">The {property.PropertyName} value.</param>");
        sb.AppendLine($"        /// <returns>The formatted partition key value.</returns>");
        sb.AppendLine($"        public static string {methodName}({parameterType} {parameterName})");
        sb.AppendLine("        {");
        
        GenerateKeyBuilderBody(sb, keyFormat, new[] { (parameterName, property.PropertyType) });
        
        sb.AppendLine("        }");
    }
    
    /// <summary>
    /// Generates a sort key builder method.
    /// </summary>
    private static void GenerateSortKeyBuilder(StringBuilder sb, PropertyModel property, string methodName, bool isMainTable, IndexModel? index = null)
    {
        var keyFormat = GetKeyFormat(property, index, isPartitionKey: false);
        var parameterType = GetParameterType(property.PropertyType);
        var parameterName = GetParameterName(property.PropertyName);
        
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>");
        sb.AppendLine($"        /// Builds the sort key value for {property.PropertyName}.");
        if (!isMainTable && index != null)
        {
            sb.AppendLine($"        /// Used for {index.IndexName} Global Secondary Index.");
        }
        sb.AppendLine($"        /// </summary>");
        sb.AppendLine($"        /// <param name=\"{parameterName}\">The {property.PropertyName} value.</param>");
        sb.AppendLine($"        /// <returns>The formatted sort key value.</returns>");
        sb.AppendLine($"        public static string {methodName}({parameterType} {parameterName})");
        sb.AppendLine("        {");
        
        GenerateKeyBuilderBody(sb, keyFormat, new[] { (parameterName, property.PropertyType) });
        
        sb.AppendLine("        }");
    }
    
    /// <summary>
    /// Generates a composite key builder method that accepts both partition and sort key parameters.
    /// </summary>
    private static void GenerateCompositeKeyBuilder(StringBuilder sb, PropertyModel partitionKeyProperty, PropertyModel sortKeyProperty, string methodName, bool isMainTable, IndexModel? index = null)
    {
        var pkParameterType = GetParameterType(partitionKeyProperty.PropertyType);
        var pkParameterName = GetParameterName(partitionKeyProperty.PropertyName);
        var skParameterType = GetParameterType(sortKeyProperty.PropertyType);
        var skParameterName = GetParameterName(sortKeyProperty.PropertyName);
        
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>");
        sb.AppendLine($"        /// Builds a composite key containing both partition and sort key values.");
        if (!isMainTable && index != null)
        {
            sb.AppendLine($"        /// Used for {index.IndexName} Global Secondary Index.");
        }
        sb.AppendLine($"        /// </summary>");
        sb.AppendLine($"        /// <param name=\"{pkParameterName}\">The {partitionKeyProperty.PropertyName} value.</param>");
        sb.AppendLine($"        /// <param name=\"{skParameterName}\">The {sortKeyProperty.PropertyName} value.</param>");
        sb.AppendLine($"        /// <returns>A tuple containing the formatted partition key and sort key values.</returns>");
        sb.AppendLine($"        public static (string PartitionKey, string SortKey) {methodName}({pkParameterType} {pkParameterName}, {skParameterType} {skParameterName})");
        sb.AppendLine("        {");
        sb.AppendLine($"            return (Pk({pkParameterName}), Sk({skParameterName}));");
        sb.AppendLine("        }");
    }
    
    /// <summary>
    /// Gets the key format information for a property, considering GSI-specific formats.
    /// </summary>
    private static KeyFormatInfo GetKeyFormat(PropertyModel property, IndexModel? index, bool isPartitionKey)
    {
        // Check if there's a GSI-specific format
        if (index != null)
        {
            var gsiAttribute = property.GlobalSecondaryIndexes.FirstOrDefault(gsi => gsi.IndexName == index.IndexName);
            if (gsiAttribute != null && !string.IsNullOrEmpty(gsiAttribute.KeyFormat))
            {
                return ParseKeyFormat(gsiAttribute.KeyFormat!);
            }
        }
        
        // Use property-level key format if available
        if (property.KeyFormat != null)
        {
            return new KeyFormatInfo
            {
                Prefix = property.KeyFormat.Prefix,
                Separator = property.KeyFormat.Separator
            };
        }
        
        // Default format
        return new KeyFormatInfo
        {
            Prefix = null,
            Separator = "#"
        };
    }
    
    /// <summary>
    /// Parses a key format string into components.
    /// </summary>
    private static KeyFormatInfo ParseKeyFormat(string keyFormat)
    {
        // Simple parsing for now - can be enhanced for more complex formats
        // Format examples: "tenant#{0}", "{0}#{1}", "prefix_{0}"
        
        var info = new KeyFormatInfo { Separator = "#" };
        
        // Extract prefix if format starts with text before {0}
        var firstPlaceholder = keyFormat.IndexOf("{0}");
        if (firstPlaceholder > 0)
        {
            var prefix = keyFormat.Substring(0, firstPlaceholder);
            // Remove common separators from the end of prefix
            prefix = prefix.TrimEnd('#', '_', '-', ':', '|');
            info.Prefix = prefix;
            
            // Determine separator from what was trimmed
            var separatorStart = prefix.Length;
            if (separatorStart < firstPlaceholder)
            {
                info.Separator = keyFormat.Substring(separatorStart, firstPlaceholder - separatorStart);
            }
        }
        
        return info;
    }
    
    /// <summary>
    /// Generates the method body for a key builder with comprehensive validation and error handling.
    /// </summary>
    private static void GenerateKeyBuilderBody(StringBuilder sb, KeyFormatInfo keyFormat, (string parameterName, string propertyType)[] parameters)
    {
        // Add comprehensive parameter validation
        foreach (var (parameterName, propertyType) in parameters)
        {
            GenerateParameterValidation(sb, parameterName, propertyType);
        }
        
        // Add try-catch for key generation errors
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        
        // Generate the key construction logic
        if (parameters.Length == 1)
        {
            var (parameterName, propertyType) = parameters[0];
            var valueExpression = GetValueExpression(parameterName, propertyType);
            
            if (!string.IsNullOrEmpty(keyFormat.Prefix))
            {
                sb.AppendLine($"                var keyValue = \"{keyFormat.Prefix}{keyFormat.Separator}\" + {valueExpression};");
            }
            else
            {
                sb.AppendLine($"                var keyValue = {valueExpression};");
            }
        }
        else
        {
            // Multiple parameters - build composite key
            var valueExpressions = parameters.Select(p => GetValueExpression(p.parameterName, p.propertyType)).ToArray();
            var separator = keyFormat.Separator;
            
            if (!string.IsNullOrEmpty(keyFormat.Prefix))
            {
                sb.AppendLine($"                var keyValue = \"{keyFormat.Prefix}{separator}\" + string.Join(\"{separator}\", {string.Join(", ", valueExpressions)});");
            }
            else
            {
                sb.AppendLine($"                var keyValue = string.Join(\"{separator}\", {string.Join(", ", valueExpressions)});");
            }
        }
        
        // Add key validation
        sb.AppendLine();
        sb.AppendLine("                // Validate generated key");
        sb.AppendLine("                if (string.IsNullOrEmpty(keyValue))");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw new System.ArgumentException(\"Generated key cannot be null or empty. Check input parameters.\");");
        sb.AppendLine("                }");
        sb.AppendLine();
        sb.AppendLine("                if (keyValue.Length > 2048)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw new System.ArgumentException($\"Generated key length ({{keyValue.Length}}) exceeds DynamoDB limit of 2048 bytes.\");");
        sb.AppendLine("                }");
        sb.AppendLine();
        sb.AppendLine("                return keyValue;");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (System.ArgumentException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Re-throw argument exceptions as-is");
        sb.AppendLine("                throw;");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (System.Exception ex)");
        sb.AppendLine("            {");
        
        // Generate specific error message based on parameters
        var parameterInfo = string.Join(", ", parameters.Select(p => $"{p.parameterName}: {{{p.parameterName}}}"));
        sb.AppendLine($"                throw new System.InvalidOperationException(");
        sb.AppendLine($"                    $\"Failed to generate key with parameters: {parameterInfo}. {{ex.Message}}\", ex);");
        sb.AppendLine("            }");
    }

    /// <summary>
    /// Generates comprehensive parameter validation for key builder methods.
    /// </summary>
    private static void GenerateParameterValidation(StringBuilder sb, string parameterName, string propertyType)
    {
        // Null checks for nullable parameters
        if (IsNullableType(propertyType))
        {
            sb.AppendLine($"            if ({parameterName} == null)");
            sb.AppendLine($"                throw new System.ArgumentNullException(nameof({parameterName}), \"Key parameter cannot be null.\");");
            sb.AppendLine();
        }
        
        // String-specific validation
        if (propertyType == "string" || propertyType == "string?")
        {
            sb.AppendLine($"            if (string.IsNullOrWhiteSpace({parameterName}))");
            sb.AppendLine($"                throw new System.ArgumentException(\"String key parameter cannot be null, empty, or whitespace.\", nameof({parameterName}));");
            sb.AppendLine();
            
            // Check for problematic characters in string keys
            sb.AppendLine($"            if ({parameterName}.Contains('\\0'))");
            sb.AppendLine($"                throw new System.ArgumentException(\"Key parameter cannot contain null characters.\", nameof({parameterName}));");
            sb.AppendLine();
        }
        
        // Guid-specific validation
        if (propertyType.Contains("Guid"))
        {
            sb.AppendLine($"            if ({parameterName} == System.Guid.Empty)");
            sb.AppendLine($"                throw new System.ArgumentException(\"Guid key parameter cannot be empty.\", nameof({parameterName}));");
            sb.AppendLine();
        }
        
        // DateTime-specific validation
        if (propertyType.Contains("DateTime"))
        {
            sb.AppendLine($"            if ({parameterName} == default)");
            sb.AppendLine($"                throw new System.ArgumentException(\"DateTime key parameter cannot be default value.\", nameof({parameterName}));");
            sb.AppendLine();
        }
        
        // Numeric validation for negative values that might be problematic
        if (IsNumericType(propertyType) && !propertyType.Contains("uint") && !propertyType.Contains("UInt"))
        {
            sb.AppendLine($"            if ({parameterName} < 0)");
            sb.AppendLine($"                System.Diagnostics.Debug.WriteLine($\"Warning: Negative value {{{{parameterName}}}} used in key generation may cause sorting issues.\");");
            sb.AppendLine();
        }
    }
    
    /// <summary>
    /// Gets the appropriate parameter type for a property type.
    /// </summary>
    private static string GetParameterType(string propertyType)
    {
        // Handle nullable types
        if (propertyType.EndsWith("?"))
        {
            return propertyType;
        }
        
        // Handle generic nullable types
        if (propertyType.StartsWith("System.Nullable<") || propertyType.StartsWith("Nullable<"))
        {
            return propertyType;
        }
        
        return propertyType;
    }
    
    /// <summary>
    /// Gets a safe parameter name from a property name.
    /// </summary>
    private static string GetParameterName(string propertyName)
    {
        // Convert to camelCase
        if (string.IsNullOrEmpty(propertyName))
            return "value";
            
        return char.ToLowerInvariant(propertyName[0]) + propertyName.Substring(1);
    }
    
    /// <summary>
    /// Gets the expression to convert a parameter to string for key building.
    /// </summary>
    private static string GetValueExpression(string parameterName, string propertyType)
    {
        // Handle different types appropriately
        if (propertyType == "string" || propertyType == "string?")
        {
            return parameterName;
        }
        
        // Handle Guid types
        if (propertyType.Contains("Guid"))
        {
            return $"{parameterName}.ToString()";
        }
        
        // Handle Ulid types (common in DynamoDB scenarios)
        if (propertyType.Contains("Ulid"))
        {
            return $"{parameterName}.ToString()";
        }
        
        // Handle DateTime types
        if (propertyType.Contains("DateTime"))
        {
            return $"{parameterName}.ToString(\"yyyy-MM-ddTHH:mm:ss.fffZ\")";
        }
        
        // Handle DateTimeOffset types
        if (propertyType.Contains("DateTimeOffset"))
        {
            return $"{parameterName}.ToString(\"yyyy-MM-ddTHH:mm:ss.fffZ\")";
        }
        
        // Handle numeric types and enums
        if (IsNumericType(propertyType) || IsEnumType(propertyType))
        {
            return $"{parameterName}.ToString()";
        }
        
        // Default to ToString() for other types
        return $"{parameterName}.ToString()";
    }
    
    /// <summary>
    /// Determines if a type is nullable.
    /// </summary>
    private static bool IsNullableType(string propertyType)
    {
        return propertyType.EndsWith("?") || 
               propertyType.StartsWith("System.Nullable<") || 
               propertyType.StartsWith("Nullable<") ||
               propertyType == "string"; // strings are reference types and nullable by default
    }
    
    /// <summary>
    /// Determines if a type is numeric.
    /// </summary>
    private static bool IsNumericType(string propertyType)
    {
        var numericTypes = new HashSet<string>
        {
            "int", "int?", "System.Int32", "System.Int32?",
            "long", "long?", "System.Int64", "System.Int64?",
            "short", "short?", "System.Int16", "System.Int16?",
            "byte", "byte?", "System.Byte", "System.Byte?",
            "uint", "uint?", "System.UInt32", "System.UInt32?",
            "ulong", "ulong?", "System.UInt64", "System.UInt64?",
            "ushort", "ushort?", "System.UInt16", "System.UInt16?",
            "sbyte", "sbyte?", "System.SByte", "System.SByte?",
            "decimal", "decimal?", "System.Decimal", "System.Decimal?",
            "double", "double?", "System.Double", "System.Double?",
            "float", "float?", "System.Single", "System.Single?"
        };
        
        return numericTypes.Contains(propertyType);
    }
    
    /// <summary>
    /// Determines if a type is an enum (simplified check).
    /// </summary>
    private static bool IsEnumType(string propertyType)
    {
        // This is a simplified check - in a real implementation, we'd use semantic model
        // to determine if the type is actually an enum
        return propertyType.Contains("Status") || 
               propertyType.Contains("Type") || 
               propertyType.Contains("Kind") ||
               propertyType.Contains("State");
    }
    
    /// <summary>
    /// Converts a name to a safe class name.
    /// </summary>
    private static string GetSafeClassName(string name)
    {
        // Remove invalid characters and ensure it starts with a letter or underscore
        var safeName = new StringBuilder();
        
        for (int i = 0; i < name.Length; i++)
        {
            char c = name[i];
            
            if (i == 0)
            {
                // First character must be letter or underscore
                if (char.IsLetter(c) || c == '_')
                {
                    safeName.Append(c);
                }
                else if (char.IsDigit(c))
                {
                    safeName.Append('_').Append(c);
                }
                else
                {
                    safeName.Append('_');
                }
            }
            else
            {
                // Subsequent characters can be letters, digits, or underscores
                if (char.IsLetterOrDigit(c) || c == '_')
                {
                    safeName.Append(c);
                }
                else
                {
                    safeName.Append('_');
                }
            }
        }
        
        var result = safeName.ToString();
        
        // Ensure we don't have an empty result
        if (string.IsNullOrEmpty(result))
        {
            result = "_Keys";
        }
        
        return result;
    }
    
    /// <summary>
    /// Represents key formatting information.
    /// </summary>
    private class KeyFormatInfo
    {
        public string? Prefix { get; set; }
        public string Separator { get; set; } = "#";
    }
}