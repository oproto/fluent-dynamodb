# Design Document: Example Entity Cleanup

## Overview

This design document outlines the refactoring of four example applications (TodoList, TransactionDemo, InvoiceManager, StoreLocator) to properly use the FluentDynamoDb source generator patterns. The current implementations manually create table classes with methods that bypass the source generator's built-in functionality. The refactored examples will demonstrate the correct patterns that developers should follow.

## Architecture

### Current (Incorrect) Pattern

```
┌─────────────────────────────────────────────────────────────┐
│                    Manual Table Class                        │
├─────────────────────────────────────────────────────────────┤
│ - Manually defines Scan<TEntity>() methods                  │
│ - Manually implements hydration logic                        │
│ - Calls DynamoDbClient.PutItemAsync() directly              │
│ - Uses verbose builder patterns                              │
│ - Manual composite entity assembly                           │
└─────────────────────────────────────────────────────────────┘
```

### Target (Correct) Pattern

```
┌─────────────────────────────────────────────────────────────┐
│                 Entity with Attributes                       │
│  [DynamoDbTable("table-name", IsDefault = true)]            │
│  [GenerateEntityProperty(Name = "Entities")]                │
│  [Scannable]                                                 │
│  public partial class Entity { ... }                         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼ Source Generator
┌─────────────────────────────────────────────────────────────┐
│              Generated Table Class                           │
│  public partial class TableNameTable : DynamoDbTableBase    │
│  {                                                           │
│      public EntityAccessor Entities { get; }                │
│      // Generated: Query, Get, Put, Delete, Scan methods    │
│  }                                                           │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│              User's Partial Table Class (Optional)           │
│  public partial class TableNameTable                         │
│  {                                                           │
│      // Custom repository methods only                       │
│  }                                                           │
└─────────────────────────────────────────────────────────────┘
```

## Components and Interfaces

### 1. TodoList Example

**Entity: TodoItem**
```csharp
[DynamoDbTable("todo-items", IsDefault = true)]
[GenerateEntityProperty(Name = "TodoItems")]
[Scannable]
public partial class TodoItem
{
    [PartitionKey]
    [DynamoDbAttribute("pk")]
    public string Id { get; set; } = string.Empty;
    
    [DynamoDbAttribute("description")]
    public string Description { get; set; } = string.Empty;
    
    [DynamoDbAttribute("isComplete")]
    public bool IsComplete { get; set; }
    
    [DynamoDbAttribute("createdAt")]
    public DateTime CreatedAt { get; set; }
    
    [DynamoDbAttribute("completedAt")]
    public DateTime? CompletedAt { get; set; }
}
```

**Table Class: TodoItemsTable (minimal partial)**
```csharp
public partial class TodoItemsTable : DynamoDbTableBase
{
    public const string TableName = "todo-items";
    
    public TodoItemsTable(IAmazonDynamoDB client) : base(client, TableName)
    {
    }
    
    // Entity accessor (TodoItems) is generated by source generator
}
```

**Usage Pattern:**
```csharp
// Create
await table.TodoItems.PutAsync(new TodoItem { Id = "1", Description = "Task" });

// Read
var item = await table.TodoItems.GetAsync("1");

// Query (if needed)
var items = await table.TodoItems.Query(x => x.Id == "1").ToListAsync();

// Scan all
var allItems = await table.TodoItems.Scan().ToListAsync();

// Update
await table.TodoItems.Update("1")
    .Set(x => x.IsComplete, true)
    .Set(x => x.CompletedAt, DateTime.UtcNow)
    .UpdateAsync();

// Delete
await table.TodoItems.Delete("1").DeleteAsync();
```

### 2. TransactionDemo Example

**Entity: Account**
```csharp
[DynamoDbTable("transaction-demo", IsDefault = true)]
[GenerateEntityProperty(Name = "Accounts")]
[Scannable]
public partial class Account
{
    [PartitionKey(Prefix = "ACCOUNT")]
    [DynamoDbAttribute("pk")]
    public string Pk { get; set; } = string.Empty;
    
    [SortKey]
    [DynamoDbAttribute("sk")]
    public string Sk { get; set; } = string.Empty;
    
    [DynamoDbAttribute("accountId")]
    public string AccountId { get; set; } = string.Empty;
    
    [DynamoDbAttribute("accountName")]
    public string Name { get; set; } = string.Empty;
    
    [DynamoDbAttribute("balance")]
    public decimal Balance { get; set; }
    
    public const string ProfileSk = "PROFILE";
}
```

**Entity: TransactionRecord**
```csharp
[DynamoDbTable("transaction-demo")]
[GenerateEntityProperty(Name = "Transactions")]
public partial class TransactionRecord
{
    [PartitionKey(Prefix = "ACCOUNT")]
    [DynamoDbAttribute("pk")]
    public string Pk { get; set; } = string.Empty;
    
    [SortKey(Prefix = "TXN")]
    [DynamoDbAttribute("sk")]
    public string Sk { get; set; } = string.Empty;
    
    // ... other properties
}
```

**Table Class: TransactionDemoTable (minimal partial)**
```csharp
public partial class TransactionDemoTable : DynamoDbTableBase
{
    public const string TableName = "transaction-demo";
    
    public TransactionDemoTable(IAmazonDynamoDB client) : base(client, TableName)
    {
    }
    
    // Entity accessors (Accounts, Transactions) are generated by source generator
}
```

**Usage Pattern:**
```csharp
// Get account
var account = await table.Accounts.GetAsync(Account.Keys.Pk(accountId), Account.ProfileSk);

// Query transactions
var transactions = await table.Transactions.Query(
    x => x.Pk == Account.Keys.Pk(accountId) && x.Sk.StartsWith("TXN#")
).ToListAsync();

// Transaction write
await DynamoDbTransactions.Write
    .AddUpdate(table.Accounts, update => update
        .WithKey("pk", Account.Keys.Pk(fromAccountId))
        .WithKey("sk", Account.ProfileSk)
        .Set(x => x.Balance, x => x.Balance - amount))
    .AddUpdate(table.Accounts, update => update
        .WithKey("pk", Account.Keys.Pk(toAccountId))
        .WithKey("sk", Account.ProfileSk)
        .Set(x => x.Balance, x => x.Balance + amount))
    .ExecuteAsync();
```

### 3. InvoiceManager Example

**Entity: Customer**
```csharp
[DynamoDbTable("invoices")]
[GenerateEntityProperty(Name = "Customers")]
public partial class Customer
{
    [PartitionKey(Prefix = "CUSTOMER")]
    [DynamoDbAttribute("pk")]
    public string Pk { get; set; } = string.Empty;
    
    [SortKey]
    [DynamoDbAttribute("sk")]
    public string Sk { get; set; } = "PROFILE";
    
    // ... other properties
}
```

**Entity: Invoice (with RelatedEntity)**
```csharp
[DynamoDbTable("invoices", IsDefault = true)]
[GenerateEntityProperty(Name = "Invoices")]
public partial class Invoice
{
    [PartitionKey(Prefix = "CUSTOMER")]
    [DynamoDbAttribute("pk")]
    public string Pk { get; set; } = string.Empty;
    
    [SortKey(Prefix = "INVOICE")]
    [DynamoDbAttribute("sk")]
    public string Sk { get; set; } = string.Empty;
    
    [DynamoDbAttribute("invoiceNumber")]
    public string InvoiceNumber { get; set; } = string.Empty;
    
    // ... other properties
    
    [RelatedEntity("INVOICE#*#LINE#*", EntityType = typeof(InvoiceLine))]
    public List<InvoiceLine> Lines { get; set; } = new();
}
```

**Entity: InvoiceLine**
```csharp
[DynamoDbTable("invoices")]
[GenerateEntityProperty(Name = "InvoiceLines")]
public partial class InvoiceLine
{
    [PartitionKey(Prefix = "CUSTOMER")]
    [DynamoDbAttribute("pk")]
    public string Pk { get; set; } = string.Empty;
    
    [SortKey]
    [DynamoDbAttribute("sk")]
    public string Sk { get; set; } = string.Empty;
    
    // ... other properties
}
```

**Usage Pattern (Compound Entity):**
```csharp
// Get complete invoice with lines using ToCompoundEntityAsync
var invoice = await table.Invoices.Query(
    x => x.Pk == Customer.Keys.Pk(customerId) && x.Sk.StartsWith(Invoice.Keys.Sk(invoiceNumber))
).ToCompoundEntityAsync<Invoice>();

// The Lines collection is automatically populated from related InvoiceLine items
Console.WriteLine($"Invoice has {invoice.Lines.Count} lines");
```

### 4. StoreLocator Example

**Entity: StoreGeoHash**
```csharp
[DynamoDbTable("stores-geohash", IsDefault = true)]
[GenerateEntityProperty(Name = "Stores")]
[Scannable]
public partial class StoreGeoHash
{
    [PartitionKey]
    [DynamoDbAttribute("pk")]
    public string StoreId { get; set; } = string.Empty;
    
    [SortKey]
    [DynamoDbAttribute("sk")]
    public string Category { get; set; } = "retail";
    
    [GlobalSecondaryIndex("geohash-index", IsPartitionKey = true)]
    [DynamoDbAttribute("geohash_cell", GeoHashPrecision = 7)]
    [StoreCoordinates(LatitudeAttributeName = "lat", LongitudeAttributeName = "lon")]
    public GeoLocation Location { get; set; }
    
    [DynamoDbAttribute("store_name")]
    public string Name { get; set; } = string.Empty;
    
    [DynamoDbAttribute("address")]
    public string Address { get; set; } = string.Empty;
}
```

**Table Class: StoresGeohashTable (minimal partial)**
```csharp
public partial class StoresGeohashTable : DynamoDbTableBase
{
    public const string TableName = "stores-geohash";
    
    public StoresGeohashTable(IAmazonDynamoDB client) 
        : base(client, TableName, new FluentDynamoDbOptions().AddGeospatial())
    {
    }
    
    // Entity accessor (Stores) and index accessor (GeohashIndex) are generated
}
```

**Usage Pattern:**
```csharp
// Add store
await table.Stores.PutAsync(new StoreGeoHash 
{ 
    StoreId = "store1", 
    Name = "Coffee Shop",
    Location = new GeoLocation(37.7879, -122.4074)
});

// Spatial query using generated index accessor
var nearbyStores = await table.GeohashIndex.Query(
    x => x.Location.WithinDistanceKilometers(center, radiusKm)
).ToListAsync();

// Or using SpatialQueryAsync extension
var results = await table.GeohashIndex.SpatialQueryAsync<StoreGeoHash>(
    locationSelector: store => store.Location,
    spatialIndexType: SpatialIndexType.GeoHash,
    precision: 7,
    center: center,
    radiusKilometers: radiusKm
);
```

## Data Models

The data models remain largely unchanged from the current implementation. The key changes are:
1. Adding `[GenerateEntityProperty]` attribute to entities
2. Using `[RelatedEntity]` for composite entity relationships
3. Ensuring entities are marked `partial`

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system-essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*

Based on the prework analysis, all acceptance criteria in this specification are code structure and style requirements that are verified through code review rather than automated property-based testing. The requirements focus on:

1. **Code Organization**: Table classes should be minimal partial classes
2. **API Style**: Examples should use lambda expressions and convenience methods
3. **Method Usage**: Examples should use generated express-route methods
4. **No Manual Implementation**: Examples should not bypass the source generator

These are design-time constraints that ensure the examples teach correct patterns, rather than runtime properties that can be verified through property-based testing.

**No testable properties identified** - All requirements are structural/stylistic and verified through code review.

## Error Handling

The refactored examples will rely on the standard error handling provided by the FluentDynamoDb library:

1. **DynamoDbMappingException**: Thrown when entity mapping fails
2. **ConditionalCheckFailedException**: Thrown when conditional operations fail
3. **ResourceNotFoundException**: Thrown when tables don't exist

Examples should demonstrate proper try-catch patterns where appropriate.

## Testing Strategy

### Manual Verification

Since all requirements are structural/stylistic, verification will be done through:

1. **Code Review**: Verify table classes are minimal partial classes
2. **Compilation**: Ensure source generator produces expected code
3. **Runtime Testing**: Run each example application to verify functionality

### Functional Testing

Each example should be manually tested to verify:

1. **TodoList**: CRUD operations work correctly
2. **TransactionDemo**: Transactions execute atomically
3. **InvoiceManager**: Compound entities are assembled correctly via ToCompoundEntityAsync
4. **StoreLocator**: Spatial queries return correct results

### Build Verification

The examples should compile without warnings related to:
- Unused manual methods
- Duplicate method definitions
- Missing partial keyword
