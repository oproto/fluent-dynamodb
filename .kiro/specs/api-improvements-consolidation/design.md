# Design Document

## Overview

This design focuses on three targeted enhancements to the FluentDynamoDb LINQ expression support:

1. **Sensitive Data Redaction in Expression Logging**: Leverage existing `[Sensitive]` attribute detection to redact sensitive values in LINQ expression logs
2. **Format String Support in DynamoDbAttribute**: Add Format property and apply formatting during LINQ expression value serialization
3. **Manual Encryption Helper**: Provide explicit method for encrypting query parameters when needed

These changes build on the already-completed generic builder refactoring and LINQ expression overload generation.

## Architecture

### High-Level Component Changes

```
┌─────────────────────────────────────────────────────────────┐
│              ExpressionTranslator (Enhanced)                │
│  - Translate(Expression, EntityMetadata, SecurityMetadata)  │
│  - ApplyFormatting(PropertyMetadata, value)                 │
│  - RedactSensitiveData(PropertyMetadata, value, logger)     │
│  + Uses existing SecurityMetadata from source generator     │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│         DynamoDbAttribute (Enhanced)                        │
│  + Format property (string?)                                │
│  - Used during LINQ expression value serialization          │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│         Request Builders (Enhanced)                         │
│  QueryRequestBuilder<TEntity>                               │
│  + WithEncryptedParameter(name, value, context)             │
│  ScanRequestBuilder<TEntity>                                │
│  + WithEncryptedParameter(name, value, context)             │
└─────────────────────────────────────────────────────────────┘
```

### Key Design Principles

1. **Leverage Existing Infrastructure**: Use SecurityMetadata already generated by source generator
2. **Explicit Over Implicit**: Manual encryption helper instead of automatic encryption
3. **Consistency**: Format support matches existing format string expression behavior
4. **Security by Default**: Sensitive data redaction happens automatically when logging is enabled

## Components and Interfaces

### 1. ExpressionTranslator Enhancement

Add sensitive data redaction during logging:

```csharp
public class ExpressionTranslator
{
    private readonly ILogger? _logger;
    
    // NEW: Accept security metadata
    public TranslationResult Translate(
        Expression expression,
        ExpressionContext context,
        SecurityMetadata? securityMetadata = null)
    {
        // Existing translation logic...
        
        // NEW: When logging, check if value is from sensitive property
        if (_logger != null && securityMetadata != null)
        {
            var valueToLog = securityMetadata.IsSensitiveField(attributeName)
                ? "[REDACTED]"
                : value;
            
            _logger.LogDebug("Expression parameter {Name} = {Value}", 
                paramName, valueToLog);
        }
    }
}
```

### 2. DynamoDbAttribute Enhancement

Add Format property:

```csharp
[AttributeUsage(AttributeTargets.Property)]
public class DynamoDbAttributeAttribute : Attribute
{
    public string? AttributeName { get; set; }
    
    // NEW: Format specification
    public string? Format { get; set; }
    
    // Existing properties...
}

// Usage example
public class Transaction
{
    [DynamoDbAttribute(Format = "yyyy-MM-dd")]
    public DateTime CreatedDate { get; set; }
    
    [DynamoDbAttribute(Format = "F2")] // Two decimal places
    public decimal Amount { get; set; }
}
```

### 3. Format Application in ExpressionTranslator

Apply formatting during value serialization:

```csharp
private AttributeValue SerializeValue(object value, PropertyMetadata? propertyMetadata)
{
    // NEW: Apply format if specified
    if (propertyMetadata?.Format != null)
    {
        value = ApplyFormat(value, propertyMetadata.Format);
    }
    
    // Existing serialization logic...
}

private object ApplyFormat(object value, string format)
{
    return value switch
    {
        DateTime dt => dt.ToString(format, CultureInfo.InvariantCulture),
        decimal d => d.ToString(format, CultureInfo.InvariantCulture),
        double d => d.ToString(format, CultureInfo.InvariantCulture),
        float f => f.ToString(format, CultureInfo.InvariantCulture),
        IFormattable formattable => formattable.ToString(format, CultureInfo.InvariantCulture),
        _ => value
    };
}
```

### 4. Manual Encryption Helpers

Add encryption support through three compatible approaches:

#### 4.1 Table-Level Encrypt Method (for LINQ expressions)

```csharp
public abstract class DynamoDbTableBase
{
    private readonly IFieldEncryptor? _encryptor;
    
    // NEW: Encrypt method for use in LINQ expressions
    // Uses ambient EncryptionContext.Current for context ID (compatible with existing pattern)
    public string Encrypt(object value, string fieldName)
    {
        if (_encryptor == null)
        {
            throw new InvalidOperationException(
                "Cannot encrypt value: IFieldEncryptor not configured. " +
                "Pass an IFieldEncryptor instance to the table constructor.");
        }
        
        // Build FieldEncryptionContext using same pattern as generated code
        var context = new FieldEncryptionContext
        {
            ContextId = EncryptionContext.Current, // Uses ambient context
            CacheTtlSeconds = 300 // Default, matches generated code
        };
        
        var plaintext = System.Text.Encoding.UTF8.GetBytes(value.ToString());
        var ciphertext = _encryptor.EncryptAsync(plaintext, fieldName, context).GetAwaiter().GetResult();
        
        // Return as base64 string for use in queries
        return Convert.ToBase64String(ciphertext);
    }
}

// Usage in LINQ expression - uses ambient EncryptionContext.Current
EncryptionContext.Current = "tenant-123";
var results = await table.Query<User>()
    .Where(x => x.Ssn == table.Encrypt(ssn, "Ssn"))
    .ToListAsync();
```

#### 4.2 Pre-Encryption Helper (for variable reuse)

```csharp
public abstract class DynamoDbTableBase
{
    // NEW: Helper for pre-encrypting values
    // Alias for Encrypt to make intent clear
    public string EncryptValue(object value, string fieldName)
    {
        return Encrypt(value, fieldName);
    }
}

// Usage with pre-encryption - uses ambient EncryptionContext.Current
EncryptionContext.Current = "tenant-123";
var encryptedSsn = table.EncryptValue(ssn, "Ssn");

var results = await table.Query<User>()
    .Where(x => x.Ssn == encryptedSsn)
    .ToListAsync();
```

#### 4.3 String Expression Support (no new methods needed)

The `table.Encrypt()` method works seamlessly with existing string expression methods:

```csharp
// Usage with format string syntax
EncryptionContext.Current = "tenant-123";
var results = await table.Query<User>()
    .Where("ssn = {0}", table.Encrypt(ssn, "Ssn"))
    .ToListAsync();

// Usage with named parameters
EncryptionContext.Current = "tenant-123";
var results = await table.Query<User>()
    .Where("ssn = :ssn")
    .WithValue(":ssn", table.Encrypt(ssn, "Ssn"))
    .ToListAsync();
```

### 5. Source Generator Updates

Emit Format in property metadata:

```csharp
// Generated property metadata
public static class TransactionMetadata
{
    public static readonly PropertyMetadata CreatedDate = new()
    {
        PropertyName = "CreatedDate",
        AttributeName = "created_date",
        PropertyType = typeof(DateTime),
        Format = "yyyy-MM-dd", // NEW
        // ... existing properties
    };
}
```

## Data Models

### PropertyMetadata Enhancement

```csharp
public class PropertyMetadata
{
    public string PropertyName { get; init; }
    public string AttributeName { get; init; }
    public Type PropertyType { get; init; }
    
    // NEW: Format support
    public string? Format { get; init; }
    
    // Existing
    public bool IsComputed { get; init; }
    public bool IsExtracted { get; init; }
    public bool IsQueryable { get; init; }
}
```

### SecurityMetadata (Already Exists)

```csharp
// Already generated by source generator
internal static class UserSecurityMetadata
{
    private static readonly HashSet<string> SensitiveFields = new()
    {
        "email",
        "ssn"
    };
    
    public static bool IsSensitiveField(string attributeName) =>
        SensitiveFields.Contains(attributeName);
}
```

## Error Handling

### Encryption Errors

```csharp
// When encryption is not configured
throw new InvalidOperationException(
    "Cannot encrypt parameter: IFieldEncryptor not configured. " +
    "Pass an IFieldEncryptor instance to the table constructor.");

// When encryption fails
throw new EncryptionException(
    $"Failed to encrypt parameter '{parameterName}': {ex.Message}", ex);
```

### Format Errors

```csharp
// When format string is invalid
throw new FormatException(
    $"Invalid format string '{format}' for property '{propertyName}' of type {propertyType.Name}");
```

## Testing Strategy

### Phase 1: Sensitive Data Redaction Tests

```csharp
[Fact]
public void ExpressionTranslator_WithSensitiveProperty_RedactsInLogs()
{
    // Arrange
    var logger = new TestLogger();
    var translator = new ExpressionTranslator(logger);
    var securityMetadata = UserSecurityMetadata.Instance;
    
    // Act
    translator.Translate(
        x => x.Email == "test@example.com", 
        context, 
        securityMetadata);
    
    // Assert
    logger.Messages.Should().Contain(m => m.Contains("[REDACTED]"));
    logger.Messages.Should().NotContain(m => m.Contains("test@example.com"));
}

[Fact]
public void ExpressionTranslator_WithNonSensitiveProperty_DoesNotRedact()
{
    // Arrange
    var logger = new TestLogger();
    var translator = new ExpressionTranslator(logger);
    var securityMetadata = UserSecurityMetadata.Instance;
    
    // Act
    translator.Translate(
        x => x.Name == "John Doe", 
        context, 
        securityMetadata);
    
    // Assert
    logger.Messages.Should().Contain(m => m.Contains("John Doe"));
}
```

### Phase 2: Format String Application Tests

```csharp
[Fact]
public async Task Query_WithFormattedDateProperty_AppliesFormat()
{
    // Arrange - CreatedDate has Format = "yyyy-MM-dd"
    var date = new DateTime(2024, 10, 24, 15, 30, 0);
    
    // Act
    var request = table.Query<Transaction>(x => x.CreatedDate == date)
        .ToRequest();
    
    // Assert - verify DynamoDB received "2024-10-24" not full DateTime
    request.ExpressionAttributeValues[":v0"].S.Should().Be("2024-10-24");
}

[Fact]
public async Task Query_WithFormattedDecimal_AppliesFormat()
{
    // Arrange - Amount has Format = "F2"
    var amount = 123.456m;
    
    // Act
    var request = table.Query<Transaction>(x => x.Amount == amount)
        .ToRequest();
    
    // Assert - verify DynamoDB received "123.46"
    request.ExpressionAttributeValues[":v0"].N.Should().Be("123.46");
}
```

### Phase 3: Manual Encryption Tests

```csharp
[Fact]
public async Task Query_WithTableEncrypt_InLinqExpression_EncryptsValue()
{
    // Arrange
    var encryptor = new MockFieldEncryptor();
    var table = new UserTable(client, encryptor: encryptor);
    
    // Act
    var results = await table.Query<User>()
        .Where(x => x.EncryptedField == table.Encrypt("secret", new EncryptionContext()))
        .ToListAsync();
    
    // Assert
    encryptor.EncryptCalls.Should().Contain(c => c.Value == "secret");
}

[Fact]
public async Task Query_WithPreEncryptedValue_EncryptsValue()
{
    // Arrange
    var encryptor = new MockFieldEncryptor();
    var table = new UserTable(client, encryptor: encryptor);
    
    // Act
    var encryptedValue = table.EncryptValue("secret", new EncryptionContext());
    var results = await table.Query<User>()
        .Where(x => x.EncryptedField == encryptedValue)
        .ToListAsync();
    
    // Assert
    encryptor.EncryptCalls.Should().Contain(c => c.Value == "secret");
}

[Fact]
public async Task Query_WithEncryptedParameter_EncryptsValue()
{
    // Arrange
    var encryptor = new MockFieldEncryptor();
    var table = new UserTable(client, encryptor: encryptor);
    
    // Act
    var results = await table.Query<User>()
        .Where("encrypted_field = :val")
        .WithEncryptedParameter(":val", "secret", new EncryptionContext())
        .ToListAsync();
    
    // Assert
    encryptor.EncryptCalls.Should().Contain(c => c.Value == "secret");
}

[Fact]
public void TableEncrypt_NoEncryptor_ThrowsException()
{
    // Arrange - no encryptor configured
    var table = new UserTable(client);
    
    // Act & Assert
    var act = () => table.Encrypt("secret", new EncryptionContext());
    
    act.Should().Throw<InvalidOperationException>()
        .WithMessage("*IFieldEncryptor not configured*");
}
```

## Implementation Phases

### Phase 1: Add Format Property to DynamoDbAttribute
- Add Format property to DynamoDbAttributeAttribute
- Update XML documentation with examples

### Phase 2: Update Source Generator to Emit Format
- Read Format property during analysis
- Emit Format in PropertyMetadata

### Phase 3: Apply Format in ExpressionTranslator
- Add ApplyFormat method
- Integrate into value serialization
- Add unit tests

### Phase 4: Add Sensitive Data Redaction to ExpressionTranslator
- Accept SecurityMetadata parameter
- Check IsSensitiveField before logging values
- Add unit tests

### Phase 5: Add Manual Encryption Helpers
- Add Encrypt method to DynamoDbTableBase for use in LINQ and string expressions
- Add EncryptValue helper method to DynamoDbTableBase (alias for clarity)
- Update ExpressionTranslator to detect and handle table.Encrypt() calls in LINQ expressions
- Add error handling for missing encryptor
- Add unit tests

### Phase 6: Integration Testing
- Test format application end-to-end
- Test sensitive data redaction end-to-end
- Test manual encryption end-to-end

## Performance Considerations

### Format String Application
- Format strings are applied once per query value
- No caching needed since values change per query
- Minimal overhead compared to network I/O

### Sensitive Data Redaction
- Only applies when logging is enabled
- HashSet lookup is O(1)
- No impact on production performance if logging is disabled

### Manual Encryption
- Encryption happens once per parameter
- Same performance as existing encryption for Put/Update operations
- Developer controls when encryption is used

## Security Considerations

### Sensitive Data Redaction
- Redaction happens at logging time only
- Original values are still used in DynamoDB queries
- Applies to all log levels when logging is enabled

### Manual Encryption
- Developer explicitly controls which parameters are encrypted
- Clear error message if encryption is not configured
- Documentation explains when encryption is appropriate

## Migration Path

### For Format Support

```csharp
// Before - no formatting
public class Transaction
{
    [DynamoDbAttribute("created_date")]
    public DateTime CreatedDate { get; set; }
}

// After - with formatting
public class Transaction
{
    [DynamoDbAttribute("created_date", Format = "yyyy-MM-dd")]
    public DateTime CreatedDate { get; set; }
}
```

### For Manual Encryption

```csharp
// Before - manual encryption outside query
var context = new FieldEncryptionContext { ContextId = "tenant-123" };
var plaintext = System.Text.Encoding.UTF8.GetBytes(value);
var ciphertext = await encryptor.EncryptAsync(plaintext, "Ssn", context);
var encryptedValue = Convert.ToBase64String(ciphertext);
var results = await table.Query<User>()
    .Where("ssn = :val")
    .WithValue(":val", encryptedValue)
    .ToListAsync();

// After - Option 1: LINQ expression with table.Encrypt()
// Uses ambient EncryptionContext.Current (same as Put/Get operations)
EncryptionContext.Current = "tenant-123";
var results = await table.Query<User>()
    .Where(x => x.Ssn == table.Encrypt(value, "Ssn"))
    .ToListAsync();

// After - Option 2: Pre-encrypt helper
// Uses ambient EncryptionContext.Current
EncryptionContext.Current = "tenant-123";
var encryptedValue = table.EncryptValue(value, "Ssn");
var results = await table.Query<User>()
    .Where(x => x.Ssn == encryptedValue)
    .ToListAsync();

// After - Option 3: String expression with table.Encrypt()
// Uses ambient EncryptionContext.Current
EncryptionContext.Current = "tenant-123";
var results = await table.Query<User>()
    .Where("ssn = {0}", table.Encrypt(value, "Ssn"))
    .ToListAsync();

// Or with named parameters
var results = await table.Query<User>()
    .Where("ssn = :val")
    .WithValue(":val", table.Encrypt(value, "Ssn"))
    .ToListAsync();
```

## Open Questions

1. **Format String Validation**: Should format strings be validated at compile time or runtime?
   - **Decision**: Runtime validation with clear error messages

2. **Encryption Helper Naming**: Should it be `WithEncryptedParameter` or `WithEncryptedValue`?
   - **Decision**: `WithEncryptedParameter` to match DynamoDB terminology

3. **Security Metadata Access**: Should ExpressionTranslator access SecurityMetadata directly or receive it as parameter?
   - **Decision**: Receive as parameter for better testability and flexibility
