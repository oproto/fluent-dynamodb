# Design Document

## Overview

This design document outlines the refactoring of the scannable table functionality from a wrapper-based pattern to an attribute-based source generation pattern. The refactoring will eliminate three types (`IScannableDynamoDbTable`, `ScannableDynamoDbTable`, and the `AsScannable()` method) and replace them with a `[Scannable]` attribute that triggers source generation of `Scan()` methods directly on table classes.

This approach aligns with the library's existing patterns where operations like `Query()`, `Get()`, `Update()`, and `Delete()` are methods directly on the table class, providing a more intuitive and consistent API surface.

## Architecture

### Current Architecture (To Be Removed)

```
DynamoDbTableBase
    └── AsScannable() method
            └── Returns IScannableDynamoDbTable
                    └── Implemented by ScannableDynamoDbTable wrapper
                            └── Provides Scan() method
```

### New Architecture

```
[DynamoDbTable("MyTable")]
[Scannable]  ← New attribute
public partial class MyTableTable : DynamoDbTableBase
{
    // Generated by source generator:
    public ScanRequestBuilder Scan() { ... }
    public ScanRequestBuilder Scan(string filterExpression, params object[] values) { ... }
}
```

### Component Interaction

```
┌─────────────────────────┐
│  [Scannable] Attribute  │
│  (Attributes project)   │
└───────────┬─────────────┘
            │
            │ Detected by
            ▼
┌─────────────────────────┐
│   EntityAnalyzer        │
│   (SourceGenerator)     │
└───────────┬─────────────┘
            │
            │ Passes to
            ▼
┌─────────────────────────┐
│   TableGenerator        │
│   (SourceGenerator)     │
└───────────┬─────────────┘
            │
            │ Generates
            ▼
┌─────────────────────────┐
│   Scan() methods        │
│   (Generated code)      │
└─────────────────────────┘
```

## Components and Interfaces

### 1. ScannableAttribute

**Location:** `Oproto.FluentDynamoDb.Attributes/ScannableAttribute.cs`

**Purpose:** Marks a table class as supporting scan operations, triggering source generation of `Scan()` methods.

**Design:**
```csharp
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
public sealed class ScannableAttribute : Attribute
{
    // No properties needed - presence of attribute is sufficient
}
```

**Rationale:** Simple marker attribute follows the same pattern as other attributes in the library. No configuration is needed since scan operations don't have table-level configuration options.

### 2. EntityAnalyzer Enhancement

**Location:** `Oproto.FluentDynamoDb.SourceGenerator/Analysis/EntityAnalyzer.cs`

**Purpose:** Detect the `[Scannable]` attribute during entity analysis and store this information in the `EntityModel`.

**Design Changes:**
- Add `IsScannable` boolean property to `EntityModel` class
- Add detection logic in `ExtractTableInfo()` or new dedicated method
- Follow existing pattern used for other attributes

**Implementation Pattern:**
```csharp
private void ExtractScannableAttribute(ClassDeclarationSyntax classDecl, 
    SemanticModel semanticModel, EntityModel entityModel)
{
    var scannableAttribute = GetAttribute(classDecl, semanticModel, "ScannableAttribute");
    entityModel.IsScannable = scannableAttribute != null;
}
```

### 3. EntityModel Enhancement

**Location:** `Oproto.FluentDynamoDb.SourceGenerator/Models/EntityModel.cs`

**Purpose:** Store whether a table class is marked as scannable.

**Design Changes:**
```csharp
public class EntityModel
{
    // ... existing properties ...
    
    /// <summary>
    /// Indicates whether this table supports scan operations.
    /// Set to true when the [Scannable] attribute is present.
    /// </summary>
    public bool IsScannable { get; set; }
}
```

### 4. TableGenerator Enhancement

**Location:** `Oproto.FluentDynamoDb.SourceGenerator/Generators/TableGenerator.cs`

**Purpose:** Generate `Scan()` method overloads when `IsScannable` is true.

**Design Changes:**
- Add `GenerateScanMethods()` private method
- Call from `GenerateTableClass()` after generating operation overloads
- Follow same pattern as existing `Query()` methods

**Generated Code Pattern:**
```csharp
/// <summary>
/// Creates a new Scan operation builder for this table.
/// 
/// WARNING: Scan operations read every item in a table or index and can be very expensive.
/// Use Query operations instead whenever possible. Scan should only be used for:
/// - Data migration or ETL processes
/// - Analytics on small tables
/// - Operations where you truly need to examine every item
/// </summary>
/// <returns>A ScanRequestBuilder configured for this table.</returns>
public ScanRequestBuilder Scan() => 
    new ScanRequestBuilder(DynamoDbClient, Logger).ForTable(Name);

/// <summary>
/// Creates a new Scan operation builder with a filter expression.
/// Uses format string syntax for parameters: {0}, {1}, etc.
/// 
/// WARNING: Scan operations are expensive. Filter expressions reduce data transfer
/// but do not reduce consumed read capacity.
/// </summary>
/// <param name="filterExpression">The filter expression with format placeholders.</param>
/// <param name="values">The values to substitute into the expression.</param>
/// <returns>A ScanRequestBuilder configured with the filter.</returns>
public ScanRequestBuilder Scan(string filterExpression, params object[] values)
{
    var builder = Scan();
    return Requests.Extensions.WithFilterExpressionExtensions.WithFilter(builder, filterExpression, values);
}
```

### 5. Code Removal

**Files to Modify:**
- `Oproto.FluentDynamoDb/Storage/DynamoDbTableBase.cs` - Remove `AsScannable()` method
- `Oproto.FluentDynamoDb/Storage/IScannableDynamoDbTable.cs` - Delete file
- `Oproto.FluentDynamoDb/Storage/ScannableDynamoDbTable.cs` - Delete file

**Rationale:** These components are no longer needed with the attribute-based approach. The `ScanRequestBuilder` remains unchanged as it's still the core implementation of scan operations.

## Data Models

### EntityModel Extension

```csharp
public class EntityModel
{
    // Existing properties...
    public string ClassName { get; set; }
    public string Namespace { get; set; }
    public string TableName { get; set; }
    public PropertyModel[] Properties { get; set; }
    public IndexModel[] Indexes { get; set; }
    
    // New property
    public bool IsScannable { get; set; }
}
```

No other data model changes are required. The `ScanRequestBuilder` and `ScanResponse` classes remain unchanged.

## Error Handling

### Compile-Time Validation

1. **Missing Partial Keyword**: If `[Scannable]` is applied to a non-partial class, the existing validation in `EntityAnalyzer` will catch this and report `DiagnosticDescriptors.EntityMustBePartial`.

2. **Invalid Attribute Usage**: The `AttributeUsage` configuration prevents applying `[Scannable]` to non-class targets or multiple times.

### Runtime Behavior

No runtime validation is needed. The generated `Scan()` methods delegate to `ScanRequestBuilder`, which handles all runtime validation and error handling.

### Migration Considerations

Since there are no external users yet, no migration path is needed. However, internal code using `AsScannable()` will need to be updated:

**Before:**
```csharp
var results = await table.AsScannable().Scan()
    .WithFilter("status = :active")
    .WithValue(":active", "ACTIVE")
    .ExecuteAsync();
```

**After:**
```csharp
// Add [Scannable] to table class definition
[DynamoDbTable("MyTable")]
[Scannable]
public partial class MyTableTable : DynamoDbTableBase { }

// Then use directly
var results = await table.Scan()
    .WithFilter("status = :active")
    .WithValue(":active", "ACTIVE")
    .ExecuteAsync();
```

## Testing Strategy

### Unit Tests for Source Generator

**Location:** `Oproto.FluentDynamoDb.SourceGenerator.UnitTests/`

**Test Cases:**

1. **Scannable Attribute Detection**
   - Verify `EntityAnalyzer` correctly detects `[Scannable]` attribute
   - Verify `IsScannable` is set to true when attribute is present
   - Verify `IsScannable` is set to false when attribute is absent

2. **Scan Method Generation**
   - Verify `TableGenerator` generates both `Scan()` overloads when `IsScannable` is true
   - Verify no `Scan()` methods are generated when `IsScannable` is false
   - Verify generated code compiles successfully
   - Verify generated methods have correct signatures
   - Verify generated methods include XML documentation

3. **Integration with Existing Features**
   - Verify `[Scannable]` works with single-key tables
   - Verify `[Scannable]` works with composite-key tables
   - Verify `[Scannable]` works with tables that have GSIs
   - Verify generated code includes proper using statements

### Functional Tests

**Location:** `Oproto.FluentDynamoDb.UnitTests/` or `Oproto.FluentDynamoDb.IntegrationTests/`

**Test Cases:**

1. **Generated Method Functionality**
   - Verify parameterless `Scan()` returns configured `ScanRequestBuilder`
   - Verify expression-based `Scan()` applies filter correctly
   - Verify generated methods work with method chaining
   - Verify generated methods pass correct table name to builder

2. **Manual Implementation**
   - Create test table with manually implemented `Scan()` methods
   - Verify manual implementation works without source generation
   - Verify no conflicts between manual and generated code

### Test Examples

```csharp
// Source generator test
[Fact]
public void EntityAnalyzer_DetectsScannableAttribute()
{
    var source = @"
        using Oproto.FluentDynamoDb.Attributes;
        
        [DynamoDbTable(""TestTable"")]
        [Scannable]
        public partial class TestTable { }
    ";
    
    var entityModel = AnalyzeEntity(source);
    
    Assert.True(entityModel.IsScannable);
}

// Generated code test
[Fact]
public void TableGenerator_GeneratesScanMethods_WhenScannable()
{
    var entityModel = new EntityModel 
    { 
        ClassName = "TestTable",
        IsScannable = true,
        // ... other properties
    };
    
    var generatedCode = TableGenerator.GenerateTableClass(entityModel);
    
    Assert.Contains("public ScanRequestBuilder Scan()", generatedCode);
    Assert.Contains("public ScanRequestBuilder Scan(string filterExpression, params object[] values)", generatedCode);
}

// Functional test
[Fact]
public void GeneratedScanMethod_ReturnsConfiguredBuilder()
{
    var table = new TestTable(mockClient);
    
    var builder = table.Scan();
    
    Assert.NotNull(builder);
    var request = builder.ToScanRequest();
    Assert.Equal("TestTable", request.TableName);
}
```

## Design Decisions and Rationales

### Decision 1: Marker Attribute vs Configured Attribute

**Choice:** Use a simple marker attribute with no properties.

**Rationale:** 
- Scan operations don't have table-level configuration options
- Presence/absence of the attribute is sufficient to express intent
- Simpler API is easier to understand and use
- Consistent with the "intentional friction" design goal

### Decision 2: Generate Both Method Overloads

**Choice:** Generate both `Scan()` and `Scan(string, params object[])` overloads.

**Rationale:**
- Matches the existing pattern for `Query()` methods
- Provides flexibility for developers
- Expression-based overload is convenient for simple filters
- Parameterless overload is needed for complex configurations

### Decision 3: Complete Removal of Wrapper Pattern

**Choice:** Remove `IScannableDynamoDbTable`, `ScannableDynamoDbTable`, and `AsScannable()` entirely.

**Rationale:**
- No external users means no breaking change concerns
- Simpler codebase is easier to maintain
- Eliminates wrapper allocation overhead
- More consistent with rest of library
- Reduces API surface area

### Decision 4: Keep ScanRequestBuilder Unchanged

**Choice:** Don't modify `ScanRequestBuilder` or `ScanResponse`.

**Rationale:**
- These classes work well and are well-tested
- Separation of concerns: builder handles operation logic, generator handles API surface
- Reduces risk of introducing bugs
- Maintains backward compatibility for any direct usage of `ScanRequestBuilder`

### Decision 5: Use Same Pattern as Query Methods

**Choice:** Generate `Scan()` methods using the exact same pattern as existing `Query()` methods.

**Rationale:**
- Consistency makes the API predictable
- Developers already understand the `Query()` pattern
- Reduces cognitive load
- Simplifies generator implementation by reusing patterns

## Performance Considerations

### Compile-Time Performance

- **Attribute Detection**: Minimal overhead, same as other attribute checks
- **Code Generation**: Generates ~30 lines of code per scannable table
- **Impact**: Negligible, consistent with existing generator performance

### Runtime Performance

- **Improvement**: Eliminates one object allocation (the wrapper) per `AsScannable()` call
- **Method Call**: Direct method call instead of interface dispatch through wrapper
- **Memory**: Reduces memory footprint by eliminating wrapper instances

### Comparison

**Before (Wrapper Pattern):**
```
table.AsScannable() → new ScannableDynamoDbTable(table) → Scan() → new ScanRequestBuilder()
```

**After (Generated Methods):**
```
table.Scan() → new ScanRequestBuilder()
```

The new approach eliminates one allocation and one level of indirection.

## Security Considerations

No security implications. Scan operations have the same security characteristics regardless of how they're invoked. The DynamoDB IAM permissions required for scan operations remain unchanged.

## AOT Compatibility

The generated code is fully AOT-compatible:
- No reflection is used
- All types are known at compile time
- Generated code follows same patterns as existing AOT-compatible code
- `ScanRequestBuilder` is already AOT-compatible

## Documentation Requirements

### XML Documentation

1. **ScannableAttribute**: Include comprehensive XML docs with warnings about scan costs
2. **Generated Scan() Methods**: Include XML docs with usage examples and warnings
3. **Code Examples**: Show both generated and manual implementation patterns

### Example Documentation

```csharp
/// <summary>
/// Marks a DynamoDB table class as supporting scan operations.
/// 
/// When applied to a table class, the source generator will create Scan() methods
/// that allow scanning all items in the table or index.
/// 
/// WARNING: Scan operations are expensive and should be used sparingly.
/// They consume read capacity for every item examined, not just items returned.
/// Consider using Query operations instead whenever possible.
/// 
/// Appropriate use cases for scan operations:
/// - Data migration or ETL processes
/// - Analytics on small tables (< 1000 items)
/// - Operations where you truly need to examine every item
/// - Batch operations that can tolerate high latency
/// </summary>
/// <example>
/// <code>
/// [DynamoDbTable("Users")]
/// [Scannable]
/// public partial class UsersTable : DynamoDbTableBase
/// {
///     // Scan() methods will be generated automatically
/// }
/// 
/// // Usage:
/// var activeUsers = await usersTable.Scan("status = :active")
///     .WithValue(":active", "ACTIVE")
///     .ExecuteAsync();
/// </code>
/// </example>
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
public sealed class ScannableAttribute : Attribute
{
}
```

## Alternative Approaches Considered

### Alternative 1: Keep Wrapper Pattern

**Rejected Reason:** Inconsistent with rest of library, adds unnecessary complexity, requires extra allocation.

### Alternative 2: Always Generate Scan Methods

**Rejected Reason:** Loses the "intentional friction" design goal. We want developers to explicitly opt-in to scan operations.

### Alternative 3: Configuration-Based Approach

**Rejected Reason:** Scan operations don't need configuration at the table level. A marker attribute is sufficient and simpler.

### Alternative 4: Extension Method Approach

**Rejected Reason:** Extension methods can't be conditionally generated based on attributes, and they don't integrate as cleanly with IntelliSense.
